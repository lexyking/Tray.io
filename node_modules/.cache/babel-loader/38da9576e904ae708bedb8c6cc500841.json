{"ast":null,"code":"'use strict'; // Load modules\n\nconst Net = require('net');\n\nconst Hoek = require('hoek');\n\nconst Any = require('../any');\n\nconst Ref = require('../../ref');\n\nconst JoiDate = require('../date');\n\nconst Uri = require('./uri');\n\nconst Ip = require('./ip');\n\nlet Isemail; // Loaded on demand\n// Declare internals\n\nconst internals = {\n  uriRegex: Uri.createUriRegex(),\n  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n  guidBrackets: {\n    '{': '}',\n    '[': ']',\n    '(': ')',\n    '': ''\n  },\n  guidVersions: {\n    uuidv1: '1',\n    uuidv2: '2',\n    uuidv3: '3',\n    uuidv4: '4',\n    uuidv5: '5'\n  },\n  cidrPresences: ['required', 'optional', 'forbidden'],\n  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\ninternals.String = class extends Any {\n  constructor() {\n    super();\n    this._type = 'string';\n\n    this._invalids.add('');\n  }\n\n  _base(value, state, options) {\n    if (typeof value === 'string' && options.convert) {\n      if (this._flags.normalize) {\n        value = value.normalize(this._flags.normalize);\n      }\n\n      if (this._flags.case) {\n        value = this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n      }\n\n      if (this._flags.trim) {\n        value = value.trim();\n      }\n\n      if (this._inner.replacements) {\n        for (let i = 0; i < this._inner.replacements.length; ++i) {\n          const replacement = this._inner.replacements[i];\n          value = value.replace(replacement.pattern, replacement.replacement);\n        }\n      }\n\n      if (this._flags.truncate) {\n        for (let i = 0; i < this._tests.length; ++i) {\n          const test = this._tests[i];\n\n          if (test.name === 'max') {\n            value = value.slice(0, test.arg);\n            break;\n          }\n        }\n      }\n\n      if (this._flags.byteAligned && value.length % 2 !== 0) {\n        value = \"0\".concat(value);\n      }\n    }\n\n    return {\n      value,\n      errors: typeof value === 'string' ? null : this.createError('string.base', {\n        value\n      }, state, options)\n    };\n  }\n\n  insensitive() {\n    if (this._flags.insensitive) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.insensitive = true;\n    return obj;\n  }\n\n  creditCard() {\n    return this._test('creditCard', undefined, function (value, state, options) {\n      let i = value.length;\n      let sum = 0;\n      let mul = 1;\n\n      while (i--) {\n        const char = value.charAt(i) * mul;\n        sum = sum + (char - (char > 9) * 9);\n        mul = mul ^ 3;\n      }\n\n      const check = sum % 10 === 0 && sum > 0;\n      return check ? value : this.createError('string.creditCard', {\n        value\n      }, state, options);\n    });\n  }\n\n  regex(pattern, patternOptions) {\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n    const patternObject = {\n      pattern\n    };\n\n    if (typeof patternOptions === 'string') {\n      patternObject.name = patternOptions;\n    } else if (typeof patternOptions === 'object') {\n      patternObject.invert = !!patternOptions.invert;\n\n      if (patternOptions.name) {\n        patternObject.name = patternOptions.name;\n      }\n    }\n\n    const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n    return this._test('regex', patternObject, function (value, state, options) {\n      const patternMatch = patternObject.pattern.test(value);\n\n      if (patternMatch ^ patternObject.invert) {\n        return value;\n      }\n\n      return this.createError(errorCode, {\n        name: patternObject.name,\n        pattern: patternObject.pattern,\n        value\n      }, state, options);\n    });\n  }\n\n  alphanum() {\n    return this._test('alphanum', undefined, function (value, state, options) {\n      if (/^[a-zA-Z0-9]+$/.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.alphanum', {\n        value\n      }, state, options);\n    });\n  }\n\n  token() {\n    return this._test('token', undefined, function (value, state, options) {\n      if (/^\\w+$/.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.token', {\n        value\n      }, state, options);\n    });\n  }\n\n  email(isEmailOptions) {\n    if (isEmailOptions) {\n      Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n      Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n      Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' || typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n      Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' || Number.isSafeInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0, 'minDomainAtoms must be a positive integer');\n      Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' || Number.isSafeInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0, 'errorLevel must be a non-negative integer or boolean');\n    }\n\n    return this._test('email', isEmailOptions, function (value, state, options) {\n      Isemail = Isemail || require('isemail');\n\n      try {\n        const result = Isemail.validate(value, isEmailOptions);\n\n        if (result === true || result === 0) {\n          return value;\n        }\n      } catch (e) {}\n\n      return this.createError('string.email', {\n        value\n      }, state, options);\n    });\n  }\n\n  ip(ipOptions = {}) {\n    let regex = internals.ipRegex;\n    Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n    if (ipOptions.cidr) {\n      Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n      ipOptions.cidr = ipOptions.cidr.toLowerCase();\n      Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', ')); // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n\n      if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n        regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n      }\n    } else {\n      // Set our default cidr strategy\n      ipOptions.cidr = 'optional';\n    }\n\n    let versions;\n\n    if (ipOptions.version) {\n      if (!Array.isArray(ipOptions.version)) {\n        ipOptions.version = [ipOptions.version];\n      }\n\n      Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n      versions = [];\n\n      for (let i = 0; i < ipOptions.version.length; ++i) {\n        let version = ipOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n        versions.push(version);\n      } // Make sure we have a set of versions\n\n\n      versions = Array.from(new Set(versions));\n      regex = Ip.createIpRegex(versions, ipOptions.cidr);\n    }\n\n    return this._test('ip', ipOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      if (versions) {\n        return this.createError('string.ipVersion', {\n          value,\n          cidr: ipOptions.cidr,\n          version: versions\n        }, state, options);\n      }\n\n      return this.createError('string.ip', {\n        value,\n        cidr: ipOptions.cidr\n      }, state, options);\n    });\n  }\n\n  uri(uriOptions) {\n    let customScheme = '';\n    let allowRelative = false;\n    let relativeOnly = false;\n    let allowQuerySquareBrackets = false;\n    let regex = internals.uriRegex;\n\n    if (uriOptions) {\n      Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n      const unknownOptions = Object.keys(uriOptions).filter(key => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));\n      Hoek.assert(unknownOptions.length === 0, \"options contain unknown keys: \".concat(unknownOptions));\n\n      if (uriOptions.scheme) {\n        Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n        if (!Array.isArray(uriOptions.scheme)) {\n          uriOptions.scheme = [uriOptions.scheme];\n        }\n\n        Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified'); // Flatten the array into a string to be used to match the schemes.\n\n        for (let i = 0; i < uriOptions.scheme.length; ++i) {\n          const scheme = uriOptions.scheme[i];\n          Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String'); // Add OR separators if a value already exists\n\n          customScheme = customScheme + (customScheme ? '|' : ''); // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n\n          if (scheme instanceof RegExp) {\n            customScheme = customScheme + scheme.source;\n          } else {\n            Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n            customScheme = customScheme + Hoek.escapeRegex(scheme);\n          }\n        }\n      }\n\n      if (uriOptions.allowRelative) {\n        allowRelative = true;\n      }\n\n      if (uriOptions.relativeOnly) {\n        relativeOnly = true;\n      }\n\n      if (uriOptions.allowQuerySquareBrackets) {\n        allowQuerySquareBrackets = true;\n      }\n    }\n\n    if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n      regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n    }\n\n    return this._test('uri', uriOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      if (relativeOnly) {\n        return this.createError('string.uriRelativeOnly', {\n          value\n        }, state, options);\n      }\n\n      if (customScheme) {\n        return this.createError('string.uriCustomScheme', {\n          scheme: customScheme,\n          value\n        }, state, options);\n      }\n\n      return this.createError('string.uri', {\n        value\n      }, state, options);\n    });\n  }\n\n  isoDate() {\n    return this._test('isoDate', undefined, function (value, state, options) {\n      if (JoiDate._isIsoDate(value)) {\n        if (!options.convert) {\n          return value;\n        }\n\n        const d = new Date(value);\n\n        if (!isNaN(d.getTime())) {\n          return d.toISOString();\n        }\n      }\n\n      return this.createError('string.isoDate', {\n        value\n      }, state, options);\n    });\n  }\n\n  guid(guidOptions) {\n    let versionNumbers = '';\n\n    if (guidOptions && guidOptions.version) {\n      if (!Array.isArray(guidOptions.version)) {\n        guidOptions.version = [guidOptions.version];\n      }\n\n      Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n      const versions = new Set();\n\n      for (let i = 0; i < guidOptions.version.length; ++i) {\n        let version = guidOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        const versionNumber = internals.guidVersions[version];\n        Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n        Hoek.assert(!versions.has(versionNumber), 'version at position ' + i + ' must not be a duplicate.');\n        versionNumbers += versionNumber;\n        versions.add(versionNumber);\n      }\n    }\n\n    const guidRegex = new RegExp(\"^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[\".concat(versionNumbers || '0-9A-F', \"][0-9A-F]{3}\\\\2?[\").concat(versionNumbers ? '89AB' : '0-9A-F', \"][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$\"), 'i');\n    return this._test('guid', guidOptions, function (value, state, options) {\n      const results = guidRegex.exec(value);\n\n      if (!results) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      } // Matching braces\n\n\n      if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      }\n\n      return value;\n    });\n  }\n\n  hex(hexOptions = {}) {\n    Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n    Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean', 'byteAligned must be boolean');\n    const byteAligned = hexOptions.byteAligned === true;\n    const regex = /^[a-f0-9]+$/i;\n\n    const obj = this._test('hex', regex, function (value, state, options) {\n      if (regex.test(value)) {\n        if (byteAligned && value.length % 2 !== 0) {\n          return this.createError('string.hexAlign', {\n            value\n          }, state, options);\n        }\n\n        return value;\n      }\n\n      return this.createError('string.hex', {\n        value\n      }, state, options);\n    });\n\n    if (byteAligned) {\n      obj._flags.byteAligned = true;\n    }\n\n    return obj;\n  }\n\n  base64(base64Options = {}) {\n    // Validation.\n    Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n    Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean', 'paddingRequired must be boolean'); // Determine if padding is required.\n\n    const paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true; // Set validation based on preference.\n\n    const regex = paddingRequired ? // Padding is required.\n    /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ // Padding is optional.\n    : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n    return this._test('base64', regex, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.base64', {\n        value\n      }, state, options);\n    });\n  }\n\n  dataUri(dataUriOptions = {}) {\n    const regex = /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/; // Determine if padding is required.\n\n    const paddingRequired = dataUriOptions.paddingRequired === false ? dataUriOptions.paddingRequired : dataUriOptions.paddingRequired || true;\n    const base64regex = paddingRequired ? /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n    return this._test('dataUri', regex, function (value, state, options) {\n      const matches = value.match(regex);\n\n      if (matches) {\n        if (!matches[2]) {\n          return value;\n        }\n\n        if (matches[2] !== 'base64') {\n          return value;\n        }\n\n        if (base64regex.test(matches[3])) {\n          return value;\n        }\n      }\n\n      return this.createError('string.dataUri', {\n        value\n      }, state, options);\n    });\n  }\n\n  hostname() {\n    const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n    return this._test('hostname', undefined, function (value, state, options) {\n      if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {\n        return value;\n      }\n\n      return this.createError('string.hostname', {\n        value\n      }, state, options);\n    });\n  }\n\n  normalize(form = 'NFC') {\n    Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n    const obj = this._test('normalize', form, function (value, state, options) {\n      if (options.convert || value === value.normalize(form)) {\n        return value;\n      }\n\n      return this.createError('string.normalize', {\n        value,\n        form\n      }, state, options);\n    });\n\n    obj._flags.normalize = form;\n    return obj;\n  }\n\n  lowercase() {\n    const obj = this._test('lowercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleLowerCase()) {\n        return value;\n      }\n\n      return this.createError('string.lowercase', {\n        value\n      }, state, options);\n    });\n\n    obj._flags.case = 'lower';\n    return obj;\n  }\n\n  uppercase() {\n    const obj = this._test('uppercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleUpperCase()) {\n        return value;\n      }\n\n      return this.createError('string.uppercase', {\n        value\n      }, state, options);\n    });\n\n    obj._flags.case = 'upper';\n    return obj;\n  }\n\n  trim(enabled = true) {\n    Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n    if (this._flags.trim && enabled || !this._flags.trim && !enabled) {\n      return this;\n    }\n\n    let obj;\n\n    if (enabled) {\n      obj = this._test('trim', undefined, function (value, state, options) {\n        if (options.convert || value === value.trim()) {\n          return value;\n        }\n\n        return this.createError('string.trim', {\n          value\n        }, state, options);\n      });\n    } else {\n      obj = this.clone();\n      obj._tests = obj._tests.filter(test => test.name !== 'trim');\n    }\n\n    obj._flags.trim = enabled;\n    return obj;\n  }\n\n  replace(pattern, replacement) {\n    if (typeof pattern === 'string') {\n      pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n    }\n\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    Hoek.assert(typeof replacement === 'string', 'replacement must be a String'); // This can not be considere a test like trim, we can't \"reject\"\n    // anything from this rule, so just clone the current object\n\n    const obj = this.clone();\n\n    if (!obj._inner.replacements) {\n      obj._inner.replacements = [];\n    }\n\n    obj._inner.replacements.push({\n      pattern,\n      replacement\n    });\n\n    return obj;\n  }\n\n  truncate(enabled) {\n    const value = enabled === undefined ? true : !!enabled;\n\n    if (this._flags.truncate === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.truncate = value;\n    return obj;\n  }\n\n};\n\ninternals.compare = function (type, compare) {\n  return function (limit, encoding) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n    return this._test(type, limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!Number.isSafeInteger(compareTo)) {\n          return this.createError('string.ref', {\n            ref: limit,\n            value: compareTo\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (compare(value, compareTo, encoding)) {\n        return value;\n      }\n\n      return this.createError('string.' + type, {\n        limit: compareTo,\n        value,\n        encoding\n      }, state, options);\n    });\n  };\n};\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length >= limit;\n});\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length <= limit;\n});\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length === limit;\n}); // Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\nmodule.exports = new internals.String();","map":null,"metadata":{},"sourceType":"script"}