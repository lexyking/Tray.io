{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Language = require('./language'); // Declare internals\n\n\nconst internals = {\n  annotations: Symbol('joi-annotations')\n};\n\ninternals.stringify = function (value, wrapArrays) {\n  const type = typeof value;\n\n  if (value === null) {\n    return 'null';\n  }\n\n  if (type === 'string') {\n    return value;\n  }\n\n  if (value instanceof exports.Err || type === 'function' || type === 'symbol') {\n    return value.toString();\n  }\n\n  if (type === 'object') {\n    if (Array.isArray(value)) {\n      let partial = '';\n\n      for (let i = 0; i < value.length; ++i) {\n        partial = partial + (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);\n      }\n\n      return wrapArrays ? '[' + partial + ']' : partial;\n    }\n\n    return value.toString();\n  }\n\n  return JSON.stringify(value);\n};\n\nexports.Err = class {\n  constructor(type, context, state, options, flags, message, template) {\n    this.isJoi = true;\n    this.type = type;\n    this.context = context || {};\n    this.context.key = state.path[state.path.length - 1];\n    this.context.label = state.key;\n    this.path = state.path;\n    this.options = options;\n    this.flags = flags;\n    this.message = message;\n    this.template = template;\n    const localized = this.options.language;\n\n    if (this.flags.label) {\n      this.context.label = this.flags.label;\n    } else if (localized && ( // language can be null for arrays exclusion check\n    this.context.label === '' || this.context.label === null)) {\n      this.context.label = localized.root || Language.errors.root;\n    }\n  }\n\n  toString() {\n    if (this.message) {\n      return this.message;\n    }\n\n    let format;\n\n    if (this.template) {\n      format = this.template;\n    }\n\n    const localized = this.options.language;\n    format = format || Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);\n\n    if (format === undefined) {\n      return \"Error code \\\"\".concat(this.type, \"\\\" is not defined, your custom type is missing the correct language definition\");\n    }\n\n    let wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');\n\n    if (typeof wrapArrays !== 'boolean') {\n      wrapArrays = Language.errors.messages.wrapArrays;\n    }\n\n    if (format === null) {\n      const childrenString = internals.stringify(this.context.reason, wrapArrays);\n\n      if (wrapArrays) {\n        return childrenString.slice(1, -1);\n      }\n\n      return childrenString;\n    }\n\n    const hasKey = /{{!?label}}/.test(format);\n    const skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';\n\n    if (skipKey) {\n      format = format.slice(2);\n    }\n\n    if (!hasKey && !skipKey) {\n      const localizedKey = Hoek.reach(localized, 'key');\n\n      if (typeof localizedKey === 'string') {\n        format = localizedKey + format;\n      } else {\n        format = Hoek.reach(Language.errors, 'key') + format;\n      }\n    }\n\n    const message = format.replace(/{{(!?)([^}]+)}}/g, ($0, isSecure, name) => {\n      const value = Hoek.reach(this.context, name);\n      const normalized = internals.stringify(value, wrapArrays);\n      return isSecure && this.options.escapeHtml ? Hoek.escapeHtml(normalized) : normalized;\n    });\n\n    this.toString = () => message; // Persist result of last toString call, it won't change\n\n\n    return message;\n  }\n\n};\n\nexports.create = function (type, context, state, options, flags, message, template) {\n  return new exports.Err(type, context, state, options, flags, message, template);\n};\n\nexports.process = function (errors, object) {\n  if (!errors) {\n    return null;\n  } // Construct error\n\n\n  let message = '';\n  const details = [];\n\n  const processErrors = function (localErrors, parent, overrideMessage) {\n    for (let i = 0; i < localErrors.length; ++i) {\n      const item = localErrors[i];\n\n      if (item instanceof Error) {\n        return item;\n      }\n\n      if (item.flags.error && typeof item.flags.error !== 'function') {\n        if (!item.flags.selfError || !item.context.reason) {\n          return item.flags.error;\n        }\n      }\n\n      let itemMessage;\n\n      if (parent === undefined) {\n        itemMessage = item.toString();\n        message = message + (message ? '. ' : '') + itemMessage;\n      } // Do not push intermediate errors, we're only interested in leafs\n\n\n      if (item.context.reason) {\n        const override = processErrors(item.context.reason, item.path, item.type === 'override' ? item.message : null);\n\n        if (override) {\n          return override;\n        }\n      } else {\n        details.push({\n          message: overrideMessage || itemMessage || item.toString(),\n          path: item.path,\n          type: item.type,\n          context: item.context\n        });\n      }\n    }\n  };\n\n  const override = processErrors(errors);\n\n  if (override) {\n    return override;\n  }\n\n  const error = new Error(message);\n  error.isJoi = true;\n  error.name = 'ValidationError';\n  error.details = details;\n  error._object = object;\n  error.annotate = internals.annotate;\n  return error;\n}; // Inspired by json-stringify-safe\n\n\ninternals.safeStringify = function (obj, spaces) {\n  return JSON.stringify(obj, internals.serializer(), spaces);\n};\n\ninternals.serializer = function () {\n  const keys = [];\n  const stack = [];\n\n  const cycleReplacer = (key, value) => {\n    if (stack[0] === value) {\n      return '[Circular ~]';\n    }\n\n    return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n  };\n\n  return function (key, value) {\n    if (stack.length > 0) {\n      const thisPos = stack.indexOf(this);\n\n      if (~thisPos) {\n        stack.length = thisPos + 1;\n        keys.length = thisPos + 1;\n        keys[thisPos] = key;\n      } else {\n        stack.push(this);\n        keys.push(key);\n      }\n\n      if (~stack.indexOf(value)) {\n        value = cycleReplacer.call(this, key, value);\n      }\n    } else {\n      stack.push(value);\n    }\n\n    if (value) {\n      const annotations = value[internals.annotations];\n\n      if (annotations) {\n        if (Array.isArray(value)) {\n          const annotated = [];\n\n          for (let i = 0; i < value.length; ++i) {\n            if (annotations.errors[i]) {\n              annotated.push(\"_$idx$_\".concat(annotations.errors[i].sort().join(', '), \"_$end$_\"));\n            }\n\n            annotated.push(value[i]);\n          }\n\n          value = annotated;\n        } else {\n          const errorKeys = Object.keys(annotations.errors);\n\n          for (let i = 0; i < errorKeys.length; ++i) {\n            const errorKey = errorKeys[i];\n            value[\"\".concat(errorKey, \"_$key$_\").concat(annotations.errors[errorKey].sort().join(', '), \"_$end$_\")] = value[errorKey];\n            value[errorKey] = undefined;\n          }\n\n          const missingKeys = Object.keys(annotations.missing);\n\n          for (let i = 0; i < missingKeys.length; ++i) {\n            const missingKey = missingKeys[i];\n            value[\"_$miss$_\".concat(missingKey, \"|\").concat(annotations.missing[missingKey], \"_$end$_\")] = '__missing__';\n          }\n        }\n\n        return value;\n      }\n    }\n\n    if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === 'function' || typeof value === 'symbol') {\n      return '[' + value.toString() + ']';\n    }\n\n    return value;\n  };\n};\n\ninternals.annotate = function (stripColorCodes) {\n  const redFgEscape = stripColorCodes ? '' : '\\u001b[31m';\n  const redBgEscape = stripColorCodes ? '' : '\\u001b[41m';\n  const endColor = stripColorCodes ? '' : '\\u001b[0m';\n\n  if (typeof this._object !== 'object') {\n    return this.details[0].message;\n  }\n\n  const obj = Hoek.clone(this._object || {});\n\n  for (let i = this.details.length - 1; i >= 0; --i) {\n    // Reverse order to process deepest child first\n    const pos = i + 1;\n    const error = this.details[i];\n    const path = error.path;\n    let ref = obj;\n\n    for (let j = 0;; ++j) {\n      const seg = path[j];\n\n      if (ref.isImmutable) {\n        ref = ref.clone(); // joi schemas are not cloned by hoek, we have to take this extra step\n      }\n\n      if (j + 1 < path.length && ref[seg] && typeof ref[seg] !== 'string') {\n        ref = ref[seg];\n      } else {\n        const refAnnotations = ref[internals.annotations] = ref[internals.annotations] || {\n          errors: {},\n          missing: {}\n        };\n        const value = ref[seg];\n        const cacheKey = seg || error.context.label;\n\n        if (value !== undefined) {\n          refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];\n          refAnnotations.errors[cacheKey].push(pos);\n        } else {\n          refAnnotations.missing[cacheKey] = pos;\n        }\n\n        break;\n      }\n    }\n  }\n\n  const replacers = {\n    key: /_\\$key\\$_([, \\d]+)_\\$end\\$_\"/g,\n    missing: /\"_\\$miss\\$_([^|]+)\\|(\\d+)_\\$end\\$_\": \"__missing__\"/g,\n    arrayIndex: /\\s*\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\",?\\n(.*)/g,\n    specials: /\"\\[(NaN|Symbol.*|-?Infinity|function.*|\\(.*)]\"/g\n  };\n  let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => \"\\\" \".concat(redFgEscape, \"[\").concat($1, \"]\").concat(endColor)).replace(replacers.missing, ($0, $1, $2) => \"\".concat(redBgEscape, \"\\\"\").concat($1, \"\\\"\").concat(endColor).concat(redFgEscape, \" [\").concat($2, \"]: -- missing --\").concat(endColor)).replace(replacers.arrayIndex, ($0, $1, $2) => \"\\n\".concat($2, \" \").concat(redFgEscape, \"[\").concat($1, \"]\").concat(endColor)).replace(replacers.specials, ($0, $1) => $1);\n  message = \"\".concat(message, \"\\n\").concat(redFgEscape);\n\n  for (let i = 0; i < this.details.length; ++i) {\n    const pos = i + 1;\n    message = \"\".concat(message, \"\\n[\").concat(pos, \"] \").concat(this.details[i].message);\n  }\n\n  message = message + endColor;\n  return message;\n};","map":null,"metadata":{},"sourceType":"script"}