{"ast":null,"code":"'use strict';\n\nconst Ref = require('./ref');\n\nconst internals = {};\n\ninternals.extendedCheckForValue = function (value, insensitive) {\n  const valueType = typeof value;\n\n  if (valueType === 'object') {\n    if (value instanceof Date) {\n      return item => {\n        return item instanceof Date && value.getTime() === item.getTime();\n      };\n    }\n\n    if (Buffer.isBuffer(value)) {\n      return item => {\n        return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');\n      };\n    }\n  } else if (insensitive && valueType === 'string') {\n    const lowercaseValue = value.toLowerCase();\n    return item => {\n      return typeof item === 'string' && lowercaseValue === item.toLowerCase();\n    };\n  }\n\n  return null;\n};\n\nmodule.exports = class InternalSet {\n  constructor(from) {\n    this._set = new Set(from);\n    this._hasRef = false;\n  }\n\n  add(value, refs) {\n    const isRef = Ref.isRef(value);\n\n    if (!isRef && this.has(value, null, null, false)) {\n      return this;\n    }\n\n    if (refs !== undefined) {\n      // If it's a merge, we don't have any refs\n      Ref.push(refs, value);\n    }\n\n    this._set.add(value);\n\n    this._hasRef |= isRef;\n    return this;\n  }\n\n  merge(add, remove) {\n    for (const item of add._set) {\n      this.add(item);\n    }\n\n    for (const item of remove._set) {\n      this.remove(item);\n    }\n\n    return this;\n  }\n\n  remove(value) {\n    this._set.delete(value);\n\n    return this;\n  }\n\n  has(value, state, options, insensitive) {\n    return !!this.get(value, state, options, insensitive);\n  }\n\n  get(value, state, options, insensitive) {\n    if (!this._set.size) {\n      return false;\n    }\n\n    const hasValue = this._set.has(value);\n\n    if (hasValue) {\n      return {\n        value\n      };\n    }\n\n    const extendedCheck = internals.extendedCheckForValue(value, insensitive);\n\n    if (!extendedCheck) {\n      if (state && this._hasRef) {\n        for (let item of this._set) {\n          if (Ref.isRef(item)) {\n            item = [].concat(item(state.reference || state.parent, options));\n            const found = item.indexOf(value);\n\n            if (found >= 0) {\n              return {\n                value: item[found]\n              };\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    return this._has(value, state, options, extendedCheck);\n  }\n\n  _has(value, state, options, check) {\n    const checkRef = !!(state && this._hasRef);\n\n    const isReallyEqual = function (item) {\n      if (value === item) {\n        return true;\n      }\n\n      return check(item);\n    };\n\n    for (let item of this._set) {\n      if (checkRef && Ref.isRef(item)) {\n        // Only resolve references if there is a state, otherwise it's a merge\n        item = item(state.reference || state.parent, options);\n\n        if (Array.isArray(item)) {\n          const found = item.findIndex(isReallyEqual);\n\n          if (found >= 0) {\n            return {\n              value: item[found]\n            };\n          }\n\n          continue;\n        }\n      }\n\n      if (isReallyEqual(item)) {\n        return {\n          value: item\n        };\n      }\n    }\n\n    return false;\n  }\n\n  values(options) {\n    if (options && options.stripUndefined) {\n      const values = [];\n\n      for (const item of this._set) {\n        if (item !== undefined) {\n          values.push(item);\n        }\n      }\n\n      return values;\n    }\n\n    return Array.from(this._set);\n  }\n\n  slice() {\n    const set = new InternalSet(this._set);\n    set._hasRef = this._hasRef;\n    return set;\n  }\n\n  concat(source) {\n    const set = new InternalSet([...this._set, ...source._set]);\n    set._hasRef = !!(this._hasRef | source._hasRef);\n    return set;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}