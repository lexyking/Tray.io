{"ast":null,"code":"'use strict'; // Load modules\n\nconst Any = require('../any');\n\nconst Ref = require('../../ref');\n\nconst Hoek = require('hoek'); // Declare internals\n\n\nconst internals = {};\ninternals.isoDate = /^(?:[-+]\\d{2})?(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/;\ninternals.invalidDate = new Date('');\n\ninternals.isIsoDate = (() => {\n  const isoString = internals.isoDate.toString();\n  return date => {\n    return date && date.toString() === isoString;\n  };\n})();\n\ninternals.Date = class extends Any {\n  constructor() {\n    super();\n    this._type = 'date';\n  }\n\n  _base(value, state, options) {\n    const result = {\n      value: options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier) || value\n    };\n\n    if (result.value instanceof Date && !isNaN(result.value.getTime())) {\n      result.errors = null;\n    } else if (!options.convert) {\n      result.errors = this.createError('date.strict', {\n        value\n      }, state, options);\n    } else {\n      let type;\n\n      if (internals.isIsoDate(this._flags.format)) {\n        type = 'isoDate';\n      } else if (this._flags.timestamp) {\n        type = \"timestamp.\".concat(this._flags.timestamp);\n      } else {\n        type = 'base';\n      }\n\n      result.errors = this.createError(\"date.\".concat(type), {\n        value\n      }, state, options);\n    }\n\n    return result;\n  }\n\n  static toDate(value, format, timestamp, multiplier) {\n    if (value instanceof Date) {\n      return value;\n    }\n\n    if (typeof value === 'string' || typeof value === 'number' && !isNaN(value) && isFinite(value)) {\n      const isIsoDate = format && internals.isIsoDate(format);\n\n      if (!isIsoDate && typeof value === 'string' && /^[+-]?\\d+(\\.\\d+)?$/.test(value)) {\n        value = parseFloat(value);\n      }\n\n      let date;\n\n      if (isIsoDate) {\n        date = format.test(value) ? new Date(value.toString()) : internals.invalidDate;\n      } else if (timestamp) {\n        date = /^\\s*$/.test(value) ? internals.invalidDate : new Date(value * multiplier);\n      } else {\n        date = new Date(value);\n      }\n\n      if (!isNaN(date.getTime())) {\n        return date;\n      }\n    }\n\n    return null;\n  }\n\n  iso() {\n    if (this._flags.format === internals.isoDate) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.format = internals.isoDate;\n    return obj;\n  }\n\n  timestamp(type = 'javascript') {\n    const allowed = ['javascript', 'unix'];\n    Hoek.assert(allowed.includes(type), '\"type\" must be one of \"' + allowed.join('\", \"') + '\"');\n\n    if (this._flags.timestamp === type) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.timestamp = type;\n    obj._flags.multiplier = type === 'unix' ? 1000 : 1;\n    return obj;\n  }\n\n  _isIsoDate(value) {\n    return internals.isoDate.test(value);\n  }\n\n};\n\ninternals.compare = function (type, compare) {\n  return function (date) {\n    const isNow = date === 'now';\n    const isRef = Ref.isRef(date);\n\n    if (!isNow && !isRef) {\n      date = internals.Date.toDate(date);\n    }\n\n    Hoek.assert(date, 'Invalid date format');\n    return this._test(type, date, function (value, state, options) {\n      let compareTo;\n\n      if (isNow) {\n        compareTo = Date.now();\n      } else if (isRef) {\n        const refValue = date(state.reference || state.parent, options);\n        compareTo = internals.Date.toDate(refValue);\n\n        if (!compareTo) {\n          return this.createError('date.ref', {\n            ref: date,\n            value: refValue\n          }, state, options);\n        }\n\n        compareTo = compareTo.getTime();\n      } else {\n        compareTo = date.getTime();\n      }\n\n      if (compare(value.getTime(), compareTo)) {\n        return value;\n      }\n\n      return this.createError('date.' + type, {\n        limit: new Date(compareTo),\n        value\n      }, state, options);\n    });\n  };\n};\n\ninternals.Date.prototype.min = internals.compare('min', (value, date) => value >= date);\ninternals.Date.prototype.max = internals.compare('max', (value, date) => value <= date);\ninternals.Date.prototype.greater = internals.compare('greater', (value, date) => value > date);\ninternals.Date.prototype.less = internals.compare('less', (value, date) => value < date);\nmodule.exports = new internals.Date();","map":null,"metadata":{},"sourceType":"script"}