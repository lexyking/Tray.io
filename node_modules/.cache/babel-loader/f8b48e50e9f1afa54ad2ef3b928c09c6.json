{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek'); // Declare internals\n\n\nconst internals = {};\nmodule.exports = class Topo {\n  constructor() {\n    this._items = [];\n    this.nodes = [];\n  }\n\n  add(nodes, options) {\n    options = options || {}; // Validate rules\n\n    const before = [].concat(options.before || []);\n    const after = [].concat(options.after || []);\n    const group = options.group || '?';\n    const sort = options.sort || 0; // Used for merging only\n\n    Hoek.assert(!before.includes(group), \"Item cannot come before itself: \".concat(group));\n    Hoek.assert(!before.includes('?'), 'Item cannot come before unassociated items');\n    Hoek.assert(!after.includes(group), \"Item cannot come after itself: \".concat(group));\n    Hoek.assert(!after.includes('?'), 'Item cannot come after unassociated items');\n    [].concat(nodes).forEach((node, i) => {\n      const item = {\n        seq: this._items.length,\n        sort,\n        before,\n        after,\n        group,\n        node\n      };\n\n      this._items.push(item);\n    }); // Insert event\n\n    const error = this._sort();\n\n    Hoek.assert(!error, 'item', group !== '?' ? \"added into group \".concat(group) : '', 'created a dependencies error');\n    return this.nodes;\n  }\n\n  merge(others) {\n    others = [].concat(others);\n\n    for (let i = 0; i < others.length; ++i) {\n      const other = others[i];\n\n      if (other) {\n        for (let j = 0; j < other._items.length; ++j) {\n          const item = Object.assign({}, other._items[j]); // Shallow cloned\n\n          this._items.push(item);\n        }\n      }\n    } // Sort items\n\n\n    this._items.sort(internals.mergeSort);\n\n    for (let i = 0; i < this._items.length; ++i) {\n      this._items[i].seq = i;\n    }\n\n    const error = this._sort();\n\n    Hoek.assert(!error, 'merge created a dependencies error');\n    return this.nodes;\n  }\n\n  _sort() {\n    // Construct graph\n    const graph = {};\n    const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n    const groups = Object.create(null);\n\n    for (let i = 0; i < this._items.length; ++i) {\n      const item = this._items[i];\n      const seq = item.seq; // Unique across all items\n\n      const group = item.group; // Determine Groups\n\n      groups[group] = groups[group] || [];\n      groups[group].push(seq); // Build intermediary graph using 'before'\n\n      graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n      const after = item.after;\n\n      for (let j = 0; j < after.length; ++j) {\n        graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n      }\n    } // Expand intermediary graph\n\n\n    let graphNodes = Object.keys(graph);\n\n    for (let i = 0; i < graphNodes.length; ++i) {\n      const node = graphNodes[i];\n      const expandedGroups = [];\n      const graphNodeItems = Object.keys(graph[node]);\n\n      for (let j = 0; j < graphNodeItems.length; ++j) {\n        const group = graph[node][graphNodeItems[j]];\n        groups[group] = groups[group] || [];\n\n        for (let k = 0; k < groups[group].length; ++k) {\n          expandedGroups.push(groups[group][k]);\n        }\n      }\n\n      graph[node] = expandedGroups;\n    } // Merge intermediary graph using graphAfters into final graph\n\n\n    const afterNodes = Object.keys(graphAfters);\n\n    for (let i = 0; i < afterNodes.length; ++i) {\n      const group = afterNodes[i];\n\n      if (groups[group]) {\n        for (let j = 0; j < groups[group].length; ++j) {\n          const node = groups[group][j];\n          graph[node] = graph[node].concat(graphAfters[group]);\n        }\n      }\n    } // Compile ancestors\n\n\n    let children;\n    const ancestors = {};\n    graphNodes = Object.keys(graph);\n\n    for (let i = 0; i < graphNodes.length; ++i) {\n      const node = graphNodes[i];\n      children = graph[node];\n\n      for (let j = 0; j < children.length; ++j) {\n        ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);\n      }\n    } // Topo sort\n\n\n    const visited = {};\n    const sorted = [];\n\n    for (let i = 0; i < this._items.length; ++i) {\n      // Really looping thru item.seq values out of order\n      let next = i;\n\n      if (ancestors[i]) {\n        next = null;\n\n        for (let j = 0; j < this._items.length; ++j) {\n          // As above, these are item.seq values\n          if (visited[j] === true) {\n            continue;\n          }\n\n          if (!ancestors[j]) {\n            ancestors[j] = [];\n          }\n\n          const shouldSeeCount = ancestors[j].length;\n          let seenCount = 0;\n\n          for (let k = 0; k < shouldSeeCount; ++k) {\n            if (visited[ancestors[j][k]]) {\n              ++seenCount;\n            }\n          }\n\n          if (seenCount === shouldSeeCount) {\n            next = j;\n            break;\n          }\n        }\n      }\n\n      if (next !== null) {\n        visited[next] = true;\n        sorted.push(next);\n      }\n    }\n\n    if (sorted.length !== this._items.length) {\n      return new Error('Invalid dependencies');\n    }\n\n    const seqIndex = {};\n\n    for (let i = 0; i < this._items.length; ++i) {\n      const item = this._items[i];\n      seqIndex[item.seq] = item;\n    }\n\n    const sortedNodes = [];\n    this._items = sorted.map(value => {\n      const sortedItem = seqIndex[value];\n      sortedNodes.push(sortedItem.node);\n      return sortedItem;\n    });\n    this.nodes = sortedNodes;\n  }\n\n};\n\ninternals.mergeSort = (a, b) => {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};","map":null,"metadata":{},"sourceType":"script"}