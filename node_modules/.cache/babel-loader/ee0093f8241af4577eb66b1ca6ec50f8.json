{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Any = require('./types/any');\n\nconst Cast = require('./cast');\n\nconst Errors = require('./errors');\n\nconst Lazy = require('./types/lazy');\n\nconst Ref = require('./ref');\n\nconst Settings = require('./types/any/settings'); // Declare internals\n\n\nconst internals = {\n  alternatives: require('./types/alternatives'),\n  array: require('./types/array'),\n  boolean: require('./types/boolean'),\n  binary: require('./types/binary'),\n  date: require('./types/date'),\n  func: require('./types/func'),\n  number: require('./types/number'),\n  object: require('./types/object'),\n  string: require('./types/string'),\n  symbol: require('./types/symbol')\n};\n\ninternals.callWithDefaults = function (schema, args) {\n  Hoek.assert(this, 'Must be invoked on a Joi instance.');\n\n  if (this._defaults) {\n    schema = this._defaults(schema);\n  }\n\n  schema._currentJoi = this;\n  return schema._init(...args);\n};\n\ninternals.root = function () {\n  const any = new Any();\n  const root = any.clone();\n  Any.prototype._currentJoi = root;\n  root._currentJoi = root;\n  root._binds = new Set(['any', 'alternatives', 'alt', 'array', 'boolean', 'binary', 'date', 'func', 'number', 'object', 'string', 'symbol', 'validate', 'describe', 'compile', 'assert', 'attempt', 'lazy', 'defaults', 'extend', 'allow', 'valid', 'only', 'equal', 'invalid', 'disallow', 'not', 'required', 'exist', 'optional', 'forbidden', 'strip', 'when', 'empty', 'default']);\n\n  root.any = function (...args) {\n    Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\n    return internals.callWithDefaults.call(this, any, args);\n  };\n\n  root.alternatives = root.alt = function (...args) {\n    return internals.callWithDefaults.call(this, internals.alternatives, args);\n  };\n\n  root.array = function (...args) {\n    Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\n    return internals.callWithDefaults.call(this, internals.array, args);\n  };\n\n  root.boolean = root.bool = function (...args) {\n    Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\n    return internals.callWithDefaults.call(this, internals.boolean, args);\n  };\n\n  root.binary = function (...args) {\n    Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\n    return internals.callWithDefaults.call(this, internals.binary, args);\n  };\n\n  root.date = function (...args) {\n    Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\n    return internals.callWithDefaults.call(this, internals.date, args);\n  };\n\n  root.func = function (...args) {\n    Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\n    return internals.callWithDefaults.call(this, internals.func, args);\n  };\n\n  root.number = function (...args) {\n    Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\n    return internals.callWithDefaults.call(this, internals.number, args);\n  };\n\n  root.object = function (...args) {\n    return internals.callWithDefaults.call(this, internals.object, args);\n  };\n\n  root.string = function (...args) {\n    Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\n    return internals.callWithDefaults.call(this, internals.string, args);\n  };\n\n  root.symbol = function (...args) {\n    Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');\n    return internals.callWithDefaults.call(this, internals.symbol, args);\n  };\n\n  root.ref = function (...args) {\n    return Ref.create(...args);\n  };\n\n  root.isRef = function (ref) {\n    return Ref.isRef(ref);\n  };\n\n  root.validate = function (value, ...args\n  /*, [schema], [options], callback */\n  ) {\n    const last = args[args.length - 1];\n    const callback = typeof last === 'function' ? last : null;\n    const count = args.length - (callback ? 1 : 0);\n\n    if (count === 0) {\n      return any.validate(value, callback);\n    }\n\n    const options = count === 2 ? args[1] : undefined;\n    const schema = this.compile(args[0]);\n    return schema._validateWithOptions(value, options, callback);\n  };\n\n  root.describe = function (...args) {\n    const schema = args.length ? this.compile(args[0]) : any;\n    return schema.describe();\n  };\n\n  root.compile = function (schema) {\n    try {\n      return Cast.schema(this, schema);\n    } catch (err) {\n      if (err.hasOwnProperty('path')) {\n        err.message = err.message + '(' + err.path + ')';\n      }\n\n      throw err;\n    }\n  };\n\n  root.assert = function (value, schema, message) {\n    this.attempt(value, schema, message);\n  };\n\n  root.attempt = function (value, schema, message) {\n    const result = this.validate(value, schema);\n    const error = result.error;\n\n    if (error) {\n      if (!message) {\n        if (typeof error.annotate === 'function') {\n          error.message = error.annotate();\n        }\n\n        throw error;\n      }\n\n      if (!(message instanceof Error)) {\n        if (typeof error.annotate === 'function') {\n          error.message = \"\".concat(message, \" \").concat(error.annotate());\n        }\n\n        throw error;\n      }\n\n      throw message;\n    }\n\n    return result.value;\n  };\n\n  root.reach = function (schema, path) {\n    Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\n    Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\n\n    const reach = (sourceSchema, schemaPath) => {\n      if (!schemaPath.length) {\n        return sourceSchema;\n      }\n\n      const children = sourceSchema._inner.children;\n\n      if (!children) {\n        return;\n      }\n\n      const key = schemaPath.shift();\n\n      for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n\n        if (child.key === key) {\n          return reach(child.schema, schemaPath);\n        }\n      }\n    };\n\n    const schemaPath = typeof path === 'string' ? path ? path.split('.') : [] : path.slice();\n    return reach(schema, schemaPath);\n  };\n\n  root.lazy = function (...args) {\n    return internals.callWithDefaults.call(this, Lazy, args);\n  };\n\n  root.defaults = function (fn) {\n    Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\n    let joi = Object.create(this.any());\n    joi = fn(joi);\n    Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\n    Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\n\n    joi._defaults = schema => {\n      if (this._defaults) {\n        schema = this._defaults(schema);\n        Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\n      }\n\n      schema = fn(schema);\n      Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\n      return schema;\n    };\n\n    return joi;\n  };\n\n  root.bind = function () {\n    const joi = Object.create(this);\n\n    joi._binds.forEach(bind => {\n      joi[bind] = joi[bind].bind(joi);\n    });\n\n    return joi;\n  };\n\n  root.extend = function (...args) {\n    const extensions = Hoek.flatten(args);\n    Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\n    this.assert(extensions, root.extensionsSchema);\n    const joi = Object.create(this.any());\n    Object.assign(joi, this);\n    joi._currentJoi = joi;\n    joi._binds = new Set(joi._binds);\n\n    for (let i = 0; i < extensions.length; ++i) {\n      let extension = extensions[i];\n\n      if (typeof extension === 'function') {\n        extension = extension(joi);\n      }\n\n      this.assert(extension, root.extensionSchema);\n      const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\n\n      const ctor = base.constructor;\n      const type = class extends ctor {\n        // eslint-disable-line no-loop-func\n        constructor() {\n          super();\n\n          if (extension.base) {\n            Object.assign(this, base);\n          }\n\n          this._type = extension.name;\n\n          if (extension.language) {\n            this._settings = Settings.concat(this._settings, {\n              language: {\n                [extension.name]: extension.language\n              }\n            });\n          }\n        }\n\n      };\n\n      if (extension.coerce) {\n        type.prototype._coerce = function (value, state, options) {\n          if (ctor.prototype._coerce) {\n            const baseRet = ctor.prototype._coerce.call(this, value, state, options);\n\n            if (baseRet.errors) {\n              return baseRet;\n            }\n\n            value = baseRet.value;\n          }\n\n          const ret = extension.coerce.call(this, value, state, options);\n\n          if (ret instanceof Errors.Err) {\n            return {\n              value,\n              errors: ret\n            };\n          }\n\n          return {\n            value: ret\n          };\n        };\n      }\n\n      if (extension.pre) {\n        type.prototype._base = function (value, state, options) {\n          if (ctor.prototype._base) {\n            const baseRet = ctor.prototype._base.call(this, value, state, options);\n\n            if (baseRet.errors) {\n              return baseRet;\n            }\n\n            value = baseRet.value;\n          }\n\n          const ret = extension.pre.call(this, value, state, options);\n\n          if (ret instanceof Errors.Err) {\n            return {\n              value,\n              errors: ret\n            };\n          }\n\n          return {\n            value: ret\n          };\n        };\n      }\n\n      if (extension.rules) {\n        for (let j = 0; j < extension.rules.length; ++j) {\n          const rule = extension.rules[j];\n          const ruleArgs = rule.params ? rule.params instanceof Any ? rule.params._inner.children.map(k => k.key) : Object.keys(rule.params) : [];\n          const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\n\n          type.prototype[rule.name] = function (...rArgs) {\n            // eslint-disable-line no-loop-func\n            if (rArgs.length > ruleArgs.length) {\n              throw new Error('Unexpected number of arguments');\n            }\n\n            let hasRef = false;\n            let arg = {};\n\n            for (let k = 0; k < ruleArgs.length; ++k) {\n              arg[ruleArgs[k]] = rArgs[k];\n\n              if (!hasRef && Ref.isRef(rArgs[k])) {\n                hasRef = true;\n              }\n            }\n\n            if (validateArgs) {\n              arg = joi.attempt(arg, validateArgs);\n            }\n\n            let schema;\n\n            if (rule.validate) {\n              const validate = function (value, state, options) {\n                return rule.validate.call(this, arg, value, state, options);\n              };\n\n              schema = this._test(rule.name, arg, validate, {\n                description: rule.description,\n                hasRef\n              });\n            } else {\n              schema = this.clone();\n            }\n\n            if (rule.setup) {\n              const newSchema = rule.setup.call(schema, arg);\n\n              if (newSchema !== undefined) {\n                Hoek.assert(newSchema instanceof Any, \"Setup of extension Joi.\".concat(this._type, \"().\").concat(rule.name, \"() must return undefined or a Joi object\"));\n                schema = newSchema;\n              }\n            }\n\n            return schema;\n          };\n        }\n      }\n\n      if (extension.describe) {\n        type.prototype.describe = function () {\n          const description = ctor.prototype.describe.call(this);\n          return extension.describe.call(this, description);\n        };\n      }\n\n      const instance = new type();\n\n      joi[extension.name] = function (...extArgs) {\n        return internals.callWithDefaults.call(this, instance, extArgs);\n      };\n\n      joi._binds.add(extension.name);\n    }\n\n    return joi;\n  };\n\n  root.extensionSchema = internals.object.keys({\n    base: internals.object.type(Any, 'Joi object'),\n    name: internals.string.required(),\n    coerce: internals.func.arity(3),\n    pre: internals.func.arity(3),\n    language: internals.object,\n    describe: internals.func.arity(1),\n    rules: internals.array.items(internals.object.keys({\n      name: internals.string.required(),\n      setup: internals.func.arity(1),\n      validate: internals.func.arity(4),\n      params: [internals.object.pattern(/.*/, internals.object.type(Any, 'Joi object')), internals.object.type(internals.object.constructor, 'Joi object')],\n      description: [internals.string, internals.func.arity(1)]\n    }).or('setup', 'validate'))\n  }).strict();\n  root.extensionsSchema = internals.array.items([internals.object, internals.func.arity(1)]).strict();\n  root.version = require('../package.json').version;\n  return root;\n};\n\nmodule.exports = internals.root();","map":null,"metadata":{},"sourceType":"script"}