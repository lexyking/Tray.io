{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Settings = require('./settings');\n\nconst Ref = require('../../ref');\n\nconst Errors = require('../../errors');\n\nconst State = require('../state');\n\nconst Symbols = require('../symbols'); // Delay-loaded to prevent circular dependencies\n\n\nlet Alternatives = null;\nlet Cast = null;\nlet Schemas = null; // Declare internals\n\nconst internals = {\n  Set: require('../../set')\n};\ninternals.defaults = {\n  abortEarly: true,\n  convert: true,\n  allowUnknown: false,\n  skipFunctions: false,\n  stripUnknown: false,\n  language: {},\n  presence: 'optional',\n  strip: false,\n  noDefaults: false,\n  escapeHtml: false // context: null\n\n};\nmodule.exports = internals.Any = class {\n  constructor() {\n    Cast = Cast || require('../../cast');\n    this.isJoi = true;\n    this._type = 'any';\n    this._settings = null;\n    this._valids = new internals.Set();\n    this._invalids = new internals.Set();\n    this._tests = [];\n    this._refs = [];\n    this._flags = {\n      /*\n       presence: 'optional',                   // optional, required, forbidden, ignore\n       allowOnly: false,\n       allowUnknown: undefined,\n       default: undefined,\n       forbidden: false,\n       encoding: undefined,\n       insensitive: false,\n       trim: false,\n       normalize: undefined,                   // NFC, NFD, NFKC, NFKD\n       case: undefined,                        // upper, lower\n       empty: undefined,\n       func: false,\n       raw: false\n       */\n    };\n    this._description = null;\n    this._unit = null;\n    this._notes = [];\n    this._tags = [];\n    this._examples = [];\n    this._meta = [];\n    this._inner = {}; // Hash of arrays of immutable objects\n  }\n\n  _init() {\n    return this;\n  }\n\n  get schemaType() {\n    return this._type;\n  }\n\n  createError(type, context, state, options, flags = this._flags) {\n    return Errors.create(type, context, state, options, flags);\n  }\n\n  createOverrideError(type, context, state, options, message, template) {\n    return Errors.create(type, context, state, options, this._flags, message, template);\n  }\n\n  checkOptions(options) {\n    Schemas = Schemas || require('../../schemas');\n    const result = Schemas.options.validate(options);\n\n    if (result.error) {\n      throw new Error(result.error.details[0].message);\n    }\n  }\n\n  clone() {\n    const obj = Object.create(Object.getPrototypeOf(this));\n    obj.isJoi = true;\n    obj._currentJoi = this._currentJoi;\n    obj._type = this._type;\n    obj._settings = this._settings;\n    obj._baseType = this._baseType;\n    obj._valids = this._valids.slice();\n    obj._invalids = this._invalids.slice();\n    obj._tests = this._tests.slice();\n    obj._refs = this._refs.slice();\n    obj._flags = Hoek.clone(this._flags);\n    obj._description = this._description;\n    obj._unit = this._unit;\n    obj._notes = this._notes.slice();\n    obj._tags = this._tags.slice();\n    obj._examples = this._examples.slice();\n    obj._meta = this._meta.slice();\n    obj._inner = {};\n    const inners = Object.keys(this._inner);\n\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n    }\n\n    return obj;\n  }\n\n  concat(schema) {\n    Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n    Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n    let obj = this.clone();\n\n    if (this._type === 'any' && schema._type !== 'any') {\n      // Reset values as if we were \"this\"\n      const tmpObj = schema.clone();\n      const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n      for (let i = 0; i < keysToRestore.length; ++i) {\n        tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n      }\n\n      obj = tmpObj;\n    }\n\n    obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\n\n    obj._valids.merge(schema._valids, schema._invalids);\n\n    obj._invalids.merge(schema._invalids, schema._valids);\n\n    obj._tests.push(...schema._tests);\n\n    obj._refs.push(...schema._refs);\n\n    if (obj._flags.empty && schema._flags.empty) {\n      obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);\n      const flags = Object.assign({}, schema._flags);\n      delete flags.empty;\n      Hoek.merge(obj._flags, flags);\n    } else if (schema._flags.empty) {\n      obj._flags.empty = schema._flags.empty;\n      const flags = Object.assign({}, schema._flags);\n      delete flags.empty;\n      Hoek.merge(obj._flags, flags);\n    } else {\n      Hoek.merge(obj._flags, schema._flags);\n    }\n\n    obj._description = schema._description || obj._description;\n    obj._unit = schema._unit || obj._unit;\n\n    obj._notes.push(...schema._notes);\n\n    obj._tags.push(...schema._tags);\n\n    obj._examples.push(...schema._examples);\n\n    obj._meta.push(...schema._meta);\n\n    const inners = Object.keys(schema._inner);\n    const isObject = obj._type === 'object';\n\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      const source = schema._inner[key];\n\n      if (source) {\n        const target = obj._inner[key];\n\n        if (target) {\n          if (isObject && key === 'children') {\n            const keys = {};\n\n            for (let j = 0; j < target.length; ++j) {\n              keys[target[j].key] = j;\n            }\n\n            for (let j = 0; j < source.length; ++j) {\n              const sourceKey = source[j].key;\n\n              if (keys[sourceKey] >= 0) {\n                target[keys[sourceKey]] = {\n                  key: sourceKey,\n                  schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                };\n              } else {\n                target.push(source[j]);\n              }\n            }\n          } else {\n            obj._inner[key] = obj._inner[key].concat(source);\n          }\n        } else {\n          obj._inner[key] = source.slice();\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  _test(name, arg, func, options) {\n    const obj = this.clone();\n\n    obj._tests.push({\n      func,\n      name,\n      arg,\n      options\n    });\n\n    return obj;\n  }\n\n  _testUnique(name, arg, func, options) {\n    const obj = this.clone();\n    obj._tests = obj._tests.filter(test => test.name !== name);\n\n    obj._tests.push({\n      func,\n      name,\n      arg,\n      options\n    });\n\n    return obj;\n  }\n\n  options(options) {\n    Hoek.assert(!options.context, 'Cannot override context');\n    this.checkOptions(options);\n    const obj = this.clone();\n    obj._settings = Settings.concat(obj._settings, options);\n    return obj;\n  }\n\n  strict(isStrict) {\n    const obj = this.clone();\n    const convert = isStrict === undefined ? false : !isStrict;\n    obj._settings = Settings.concat(obj._settings, {\n      convert\n    });\n    return obj;\n  }\n\n  raw(isRaw) {\n    const value = isRaw === undefined ? true : isRaw;\n\n    if (this._flags.raw === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.raw = value;\n    return obj;\n  }\n\n  error(err, options = {\n    self: false\n  }) {\n    Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\n    const unknownKeys = Object.keys(options).filter(k => !['self'].includes(k));\n    Hoek.assert(unknownKeys.length === 0, \"Options \".concat(unknownKeys, \" are unknown\"));\n    const obj = this.clone();\n    obj._flags.error = err;\n\n    if (options.self) {\n      obj._flags.selfError = true;\n    }\n\n    return obj;\n  }\n\n  allow(...values) {\n    const obj = this.clone();\n    values = Hoek.flatten(values);\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n      obj._invalids.remove(value);\n\n      obj._valids.add(value, obj._refs);\n    }\n\n    return obj;\n  }\n\n  valid(...values) {\n    const obj = this.allow(...values);\n    obj._flags.allowOnly = true;\n    return obj;\n  }\n\n  invalid(...values) {\n    const obj = this.clone();\n    values = Hoek.flatten(values);\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n      obj._valids.remove(value);\n\n      obj._invalids.add(value, obj._refs);\n    }\n\n    return obj;\n  }\n\n  required() {\n    if (this._flags.presence === 'required') {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.presence = 'required';\n    return obj;\n  }\n\n  optional() {\n    if (this._flags.presence === 'optional') {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.presence = 'optional';\n    return obj;\n  }\n\n  forbidden() {\n    if (this._flags.presence === 'forbidden') {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.presence = 'forbidden';\n    return obj;\n  }\n\n  strip() {\n    if (this._flags.strip) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.strip = true;\n    return obj;\n  }\n\n  applyFunctionToChildren(children, fn, args = [], root) {\n    children = [].concat(children);\n\n    if (children.length !== 1 || children[0] !== '') {\n      root = root ? root + '.' : '';\n      const extraChildren = (children[0] === '' ? children.slice(1) : children).map(child => {\n        return root + child;\n      });\n      throw new Error('unknown key(s) ' + extraChildren.join(', '));\n    }\n\n    return this[fn](...args);\n  }\n\n  default(value, description) {\n    if (typeof value === 'function' && !Ref.isRef(value)) {\n      if (!value.description && description) {\n        value.description = description;\n      }\n\n      if (!this._flags.func) {\n        Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n      }\n    }\n\n    const obj = this.clone();\n    obj._flags.default = value;\n    Ref.push(obj._refs, value);\n    return obj;\n  }\n\n  empty(schema) {\n    const obj = this.clone();\n\n    if (schema === undefined) {\n      delete obj._flags.empty;\n    } else {\n      obj._flags.empty = Cast.schema(this._currentJoi, schema);\n    }\n\n    return obj;\n  }\n\n  when(condition, options) {\n    Hoek.assert(options && typeof options === 'object', 'Invalid options');\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n    const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\n    const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\n    Alternatives = Alternatives || require('../alternatives');\n    const alternativeOptions = {\n      then,\n      otherwise\n    };\n\n    if (Object.prototype.hasOwnProperty.call(options, 'is')) {\n      alternativeOptions.is = options.is;\n    }\n\n    const obj = Alternatives.when(condition, alternativeOptions);\n    obj._flags.presence = 'ignore';\n    obj._baseType = this;\n    return obj;\n  }\n\n  description(desc) {\n    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n    const obj = this.clone();\n    obj._description = desc;\n    return obj;\n  }\n\n  notes(notes) {\n    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n    const obj = this.clone();\n    obj._notes = obj._notes.concat(notes);\n    return obj;\n  }\n\n  tags(tags) {\n    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n    const obj = this.clone();\n    obj._tags = obj._tags.concat(tags);\n    return obj;\n  }\n\n  meta(meta) {\n    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n    const obj = this.clone();\n    obj._meta = obj._meta.concat(meta);\n    return obj;\n  }\n\n  example(...examples) {\n    Hoek.assert(examples.length > 0, 'Missing examples');\n    const processed = [];\n\n    for (let i = 0; i < examples.length; ++i) {\n      const example = [].concat(examples[i]);\n      Hoek.assert(example.length <= 2, \"Bad example format at index \".concat(i));\n      const value = example[0];\n      let options = example[1];\n\n      if (options !== undefined) {\n        Hoek.assert(options && typeof options === 'object', \"Options for example at index \".concat(i, \" must be an object\"));\n        const unknownOptions = Object.keys(options).filter(option => !['parent', 'context'].includes(option));\n        Hoek.assert(unknownOptions.length === 0, \"Unknown example options \".concat(unknownOptions, \" at index \").concat(i));\n      } else {\n        options = {};\n      }\n\n      const localState = new State('', [], options.parent || null);\n\n      const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? {\n        context: options.context\n      } : null));\n\n      Hoek.assert(!result.errors, \"Bad example at index \".concat(i, \":\"), result.errors && Errors.process(result.errors, value));\n      const ex = {\n        value\n      };\n\n      if (Object.keys(options).length) {\n        ex.options = options;\n      }\n\n      processed.push(ex);\n    }\n\n    const obj = this.clone();\n    obj._examples = processed;\n    return obj;\n  }\n\n  unit(name) {\n    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n    const obj = this.clone();\n    obj._unit = name;\n    return obj;\n  }\n\n  _prepareEmptyValue(value) {\n    if (typeof value === 'string' && this._flags.trim) {\n      return value.trim();\n    }\n\n    return value;\n  }\n\n  _validate(value, state, options, reference) {\n    const originalValue = value; // Setup state and settings\n\n    state = state || new State('', [], null, reference);\n\n    if (this._settings) {\n      const isDefaultOptions = options === internals.defaults;\n\n      if (isDefaultOptions && this._settings[Symbols.settingsCache]) {\n        options = this._settings[Symbols.settingsCache];\n      } else {\n        options = Settings.concat(options, this._settings);\n\n        if (isDefaultOptions) {\n          this._settings[Symbols.settingsCache] = options;\n        }\n      }\n    }\n\n    let errors = [];\n\n    if (this._coerce) {\n      const coerced = this._coerce(value, state, options);\n\n      if (coerced.errors) {\n        value = coerced.value;\n        errors = errors.concat(coerced.errors);\n        return this._finalizeValue(value, originalValue, errors, state, options); // Coerced error always aborts early\n      }\n\n      value = coerced.value;\n    }\n\n    if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n      value = undefined;\n    } // Check presence requirements\n\n\n    const presence = this._flags.presence || options.presence;\n\n    if (presence === 'optional') {\n      if (value === undefined) {\n        const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n\n        if (isDeepDefault && this._type === 'object') {\n          value = {};\n        } else {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      }\n    } else if (presence === 'required' && value === undefined) {\n      errors.push(this.createError('any.required', null, state, options));\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    } else if (presence === 'forbidden') {\n      if (value === undefined) {\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n\n      errors.push(this.createError('any.unknown', null, state, options));\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    } // Check allowed and denied values using the original value\n\n\n    let match = this._valids.get(value, state, options, this._flags.insensitive);\n\n    if (match) {\n      if (options.convert) {\n        value = match.value;\n      }\n\n      return this._finalizeValue(value, originalValue, errors, state, options);\n    }\n\n    if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n      errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n        value,\n        invalids: this._invalids.values({\n          stripUndefined: true\n        })\n      }, state, options));\n\n      if (options.abortEarly) {\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n    } // Convert value and validate type\n\n\n    if (this._base) {\n      const base = this._base(value, state, options);\n\n      if (base.errors) {\n        value = base.value;\n        errors = errors.concat(base.errors);\n        return this._finalizeValue(value, originalValue, errors, state, options); // Base error always aborts early\n      }\n\n      if (base.value !== value) {\n        value = base.value; // Check allowed and denied values using the converted value\n\n        match = this._valids.get(value, state, options, this._flags.insensitive);\n\n        if (match) {\n          value = match.value;\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n          errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n            value,\n            invalids: this._invalids.values({\n              stripUndefined: true\n            })\n          }, state, options));\n\n          if (options.abortEarly) {\n            return this._finalizeValue(value, originalValue, errors, state, options);\n          }\n        }\n      }\n    } // Required values did not match\n\n\n    if (this._flags.allowOnly) {\n      errors.push(this.createError('any.allowOnly', {\n        value,\n        valids: this._valids.values({\n          stripUndefined: true\n        })\n      }, state, options));\n\n      if (options.abortEarly) {\n        return this._finalizeValue(value, originalValue, errors, state, options);\n      }\n    } // Validate tests\n\n\n    for (let i = 0; i < this._tests.length; ++i) {\n      const test = this._tests[i];\n      const ret = test.func.call(this, value, state, options);\n\n      if (ret instanceof Errors.Err) {\n        errors.push(ret);\n\n        if (options.abortEarly) {\n          return this._finalizeValue(value, originalValue, errors, state, options);\n        }\n      } else {\n        value = ret;\n      }\n    }\n\n    return this._finalizeValue(value, originalValue, errors, state, options);\n  }\n\n  _finalizeValue(value, originalValue, errors, state, options) {\n    let finalValue;\n\n    if (value !== undefined) {\n      finalValue = this._flags.raw ? originalValue : value;\n    } else if (options.noDefaults) {\n      finalValue = value;\n    } else if (Ref.isRef(this._flags.default)) {\n      finalValue = this._flags.default(state.parent, options);\n    } else if (typeof this._flags.default === 'function' && !(this._flags.func && !this._flags.default.description)) {\n      let args;\n\n      if (state.parent !== null && this._flags.default.length > 0) {\n        args = [Hoek.clone(state.parent), options];\n      }\n\n      const defaultValue = internals._try(this._flags.default, args);\n\n      finalValue = defaultValue.value;\n\n      if (defaultValue.error) {\n        errors.push(this.createError('any.default', {\n          error: defaultValue.error\n        }, state, options));\n      }\n    } else {\n      finalValue = Hoek.clone(this._flags.default);\n    }\n\n    if (errors.length && typeof this._flags.error === 'function' && (!this._flags.selfError || errors.some(e => state.path.length === e.path.length))) {\n      const change = this._flags.error.call(this, errors);\n\n      if (typeof change === 'string') {\n        errors = [this.createOverrideError('override', {\n          reason: errors\n        }, state, options, change)];\n      } else {\n        errors = [].concat(change).map(err => {\n          return err instanceof Error ? err : this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\n        });\n      }\n    }\n\n    return {\n      value: this._flags.strip ? undefined : finalValue,\n      finalValue,\n      errors: errors.length ? errors : null\n    };\n  }\n\n  _validateWithOptions(value, options, callback) {\n    if (options) {\n      this.checkOptions(options);\n    }\n\n    const settings = Settings.concat(internals.defaults, options);\n\n    const result = this._validate(value, null, settings);\n\n    const errors = Errors.process(result.errors, value);\n\n    if (callback) {\n      return callback(errors, result.value);\n    }\n\n    return {\n      error: errors,\n      value: result.value,\n\n      then(resolve, reject) {\n        if (errors) {\n          return Promise.reject(errors).catch(reject);\n        }\n\n        return Promise.resolve(result.value).then(resolve);\n      },\n\n      catch(reject) {\n        if (errors) {\n          return Promise.reject(errors).catch(reject);\n        }\n\n        return Promise.resolve(result.value);\n      }\n\n    };\n  }\n\n  validate(value, options, callback) {\n    if (typeof options === 'function') {\n      return this._validateWithOptions(value, null, options);\n    }\n\n    return this._validateWithOptions(value, options, callback);\n  }\n\n  describe() {\n    const description = {\n      type: this._type\n    };\n    const flags = Object.keys(this._flags);\n\n    if (flags.length) {\n      if (['empty', 'default', 'lazy', 'label'].some(flag => this._flags.hasOwnProperty(flag))) {\n        description.flags = {};\n\n        for (let i = 0; i < flags.length; ++i) {\n          const flag = flags[i];\n\n          if (flag === 'empty') {\n            description.flags[flag] = this._flags[flag].describe();\n          } else if (flag === 'default') {\n            if (Ref.isRef(this._flags[flag])) {\n              description.flags[flag] = this._flags[flag].toString();\n            } else if (typeof this._flags[flag] === 'function') {\n              description.flags[flag] = {\n                description: this._flags[flag].description,\n                function: this._flags[flag]\n              };\n            } else {\n              description.flags[flag] = this._flags[flag];\n            }\n          } else if (flag === 'lazy' || flag === 'label') {// We don't want it in the description\n          } else {\n            description.flags[flag] = this._flags[flag];\n          }\n        }\n      } else {\n        description.flags = this._flags;\n      }\n    }\n\n    if (this._settings) {\n      description.options = Hoek.clone(this._settings);\n    }\n\n    if (this._baseType) {\n      description.base = this._baseType.describe();\n    }\n\n    if (this._description) {\n      description.description = this._description;\n    }\n\n    if (this._notes.length) {\n      description.notes = this._notes;\n    }\n\n    if (this._tags.length) {\n      description.tags = this._tags;\n    }\n\n    if (this._meta.length) {\n      description.meta = this._meta;\n    }\n\n    if (this._examples.length) {\n      description.examples = this._examples;\n    }\n\n    if (this._unit) {\n      description.unit = this._unit;\n    }\n\n    const valids = this._valids.values();\n\n    if (valids.length) {\n      description.valids = valids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n\n    const invalids = this._invalids.values();\n\n    if (invalids.length) {\n      description.invalids = invalids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n\n    description.rules = [];\n\n    for (let i = 0; i < this._tests.length; ++i) {\n      const validator = this._tests[i];\n      const item = {\n        name: validator.name\n      };\n\n      if (validator.arg !== void 0) {\n        item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n      }\n\n      const options = validator.options;\n\n      if (options) {\n        if (options.hasRef) {\n          item.arg = {};\n          const keys = Object.keys(validator.arg);\n\n          for (let j = 0; j < keys.length; ++j) {\n            const key = keys[j];\n            const value = validator.arg[key];\n            item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n          }\n        }\n\n        if (typeof options.description === 'string') {\n          item.description = options.description;\n        } else if (typeof options.description === 'function') {\n          item.description = options.description(item.arg);\n        }\n      }\n\n      description.rules.push(item);\n    }\n\n    if (!description.rules.length) {\n      delete description.rules;\n    }\n\n    const label = this._getLabel();\n\n    if (label) {\n      description.label = label;\n    }\n\n    return description;\n  }\n\n  label(name) {\n    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n    const obj = this.clone();\n    obj._flags.label = name;\n    return obj;\n  }\n\n  _getLabel(def) {\n    return this._flags.label || def;\n  }\n\n};\ninternals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\n\ninternals._try = function (fn, args = []) {\n  let err;\n  let result;\n\n  try {\n    result = fn(...args);\n  } catch (e) {\n    err = e;\n  }\n\n  return {\n    value: result,\n    error: err\n  };\n};","map":null,"metadata":{},"sourceType":"script"}