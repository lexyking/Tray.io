{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Any = require('../any');\n\nconst Cast = require('../../cast');\n\nconst Ref = require('../../ref');\n\nconst State = require('../state'); // Declare internals\n\n\nconst internals = {};\n\ninternals.fastSplice = function (arr, i) {\n  let pos = i;\n\n  while (pos < arr.length) {\n    arr[pos++] = arr[pos];\n  }\n\n  --arr.length;\n};\n\ninternals.Array = class extends Any {\n  constructor() {\n    super();\n    this._type = 'array';\n    this._inner.items = [];\n    this._inner.ordereds = [];\n    this._inner.inclusions = [];\n    this._inner.exclusions = [];\n    this._inner.requireds = [];\n    this._flags.sparse = false;\n  }\n\n  _base(value, state, options) {\n    const result = {\n      value\n    };\n\n    if (typeof value === 'string' && options.convert) {\n      internals.safeParse(value, result);\n    }\n\n    let isArray = Array.isArray(result.value);\n    const wasArray = isArray;\n\n    if (options.convert && this._flags.single && !isArray) {\n      result.value = [result.value];\n      isArray = true;\n    }\n\n    if (!isArray) {\n      result.errors = this.createError('array.base', null, state, options);\n      return result;\n    }\n\n    if (this._inner.inclusions.length || this._inner.exclusions.length || this._inner.requireds.length || this._inner.ordereds.length || !this._flags.sparse) {\n      // Clone the array so that we don't modify the original\n      if (wasArray) {\n        result.value = result.value.slice(0);\n      }\n\n      result.errors = this._checkItems(result.value, wasArray, state, options);\n\n      if (result.errors && wasArray && options.convert && this._flags.single) {\n        // Attempt a 2nd pass by putting the array inside one.\n        const previousErrors = result.errors;\n        result.value = [result.value];\n        result.errors = this._checkItems(result.value, wasArray, state, options);\n\n        if (result.errors) {\n          // Restore previous errors and value since this didn't validate either.\n          result.errors = previousErrors;\n          result.value = result.value[0];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  _checkItems(items, wasArray, state, options) {\n    const errors = [];\n    let errored;\n\n    const requireds = this._inner.requireds.slice();\n\n    const ordereds = this._inner.ordereds.slice();\n\n    const inclusions = [...this._inner.inclusions, ...requireds];\n    let il = items.length;\n\n    for (let i = 0; i < il; ++i) {\n      errored = false;\n      const item = items[i];\n      let isValid = false;\n      const key = wasArray ? i : state.key;\n      const path = wasArray ? [...state.path, i] : state.path;\n      const localState = new State(key, path, state.parent, state.reference);\n      let res; // Sparse\n\n      if (!this._flags.sparse && item === undefined) {\n        errors.push(this.createError('array.sparse', null, {\n          key: state.key,\n          path: localState.path,\n          pos: i\n        }, options));\n\n        if (options.abortEarly) {\n          return errors;\n        }\n\n        ordereds.shift();\n        continue;\n      } // Exclusions\n\n\n      for (let j = 0; j < this._inner.exclusions.length; ++j) {\n        res = this._inner.exclusions[j]._validate(item, localState, {}); // Not passing options to use defaults\n\n        if (!res.errors) {\n          errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', {\n            pos: i,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n          errored = true;\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          ordereds.shift();\n          break;\n        }\n      }\n\n      if (errored) {\n        continue;\n      } // Ordered\n\n\n      if (this._inner.ordereds.length) {\n        if (ordereds.length > 0) {\n          const ordered = ordereds.shift();\n          res = ordered._validate(item, localState, options);\n\n          if (!res.errors) {\n            if (ordered._flags.strip) {\n              internals.fastSplice(items, i);\n              --i;\n              --il;\n            } else if (!this._flags.sparse && res.value === undefined) {\n              errors.push(this.createError('array.sparse', null, {\n                key: state.key,\n                path: localState.path,\n                pos: i\n              }, options));\n\n              if (options.abortEarly) {\n                return errors;\n              }\n\n              continue;\n            } else {\n              items[i] = res.value;\n            }\n          } else {\n            errors.push(this.createError('array.ordered', {\n              pos: i,\n              reason: res.errors,\n              value: item\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n\n            if (options.abortEarly) {\n              return errors;\n            }\n          }\n\n          continue;\n        } else if (!this._inner.items.length) {\n          errors.push(this.createError('array.orderedLength', {\n            pos: i,\n            limit: this._inner.ordereds.length\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          continue;\n        }\n      } // Requireds\n\n\n      const requiredChecks = [];\n      let jl = requireds.length;\n\n      for (let j = 0; j < jl; ++j) {\n        res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n\n        if (!res.errors) {\n          items[i] = res.value;\n          isValid = true;\n          internals.fastSplice(requireds, j);\n          --j;\n          --jl;\n\n          if (!this._flags.sparse && res.value === undefined) {\n            errors.push(this.createError('array.sparse', null, {\n              key: state.key,\n              path: localState.path,\n              pos: i\n            }, options));\n\n            if (options.abortEarly) {\n              return errors;\n            }\n          }\n\n          break;\n        }\n      }\n\n      if (isValid) {\n        continue;\n      } // Inclusions\n\n\n      const stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;\n      jl = inclusions.length;\n\n      for (let j = 0; j < jl; ++j) {\n        const inclusion = inclusions[j]; // Avoid re-running requireds that already didn't match in the previous loop\n\n        const previousCheck = requireds.indexOf(inclusion);\n\n        if (previousCheck !== -1) {\n          res = requiredChecks[previousCheck];\n        } else {\n          res = inclusion._validate(item, localState, options);\n\n          if (!res.errors) {\n            if (inclusion._flags.strip) {\n              internals.fastSplice(items, i);\n              --i;\n              --il;\n            } else if (!this._flags.sparse && res.value === undefined) {\n              errors.push(this.createError('array.sparse', null, {\n                key: state.key,\n                path: localState.path,\n                pos: i\n              }, options));\n              errored = true;\n            } else {\n              items[i] = res.value;\n            }\n\n            isValid = true;\n            break;\n          }\n        } // Return the actual error if only one inclusion defined\n\n\n        if (jl === 1) {\n          if (stripUnknown) {\n            internals.fastSplice(items, i);\n            --i;\n            --il;\n            isValid = true;\n            break;\n          }\n\n          errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', {\n            pos: i,\n            reason: res.errors,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n          errored = true;\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          break;\n        }\n      }\n\n      if (errored) {\n        continue;\n      }\n\n      if (this._inner.inclusions.length && !isValid) {\n        if (stripUnknown) {\n          internals.fastSplice(items, i);\n          --i;\n          --il;\n          continue;\n        }\n\n        errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', {\n          pos: i,\n          value: item\n        }, {\n          key: state.key,\n          path: localState.path\n        }, options));\n\n        if (options.abortEarly) {\n          return errors;\n        }\n      }\n    }\n\n    if (requireds.length) {\n      this._fillMissedErrors(errors, requireds, state, options);\n    }\n\n    if (ordereds.length) {\n      this._fillOrderedErrors(errors, ordereds, state, options);\n    }\n\n    return errors.length ? errors : null;\n  }\n\n  describe() {\n    const description = super.describe();\n\n    if (this._inner.ordereds.length) {\n      description.orderedItems = [];\n\n      for (let i = 0; i < this._inner.ordereds.length; ++i) {\n        description.orderedItems.push(this._inner.ordereds[i].describe());\n      }\n    }\n\n    if (this._inner.items.length) {\n      description.items = [];\n\n      for (let i = 0; i < this._inner.items.length; ++i) {\n        description.items.push(this._inner.items[i].describe());\n      }\n    }\n\n    if (description.rules) {\n      for (let i = 0; i < description.rules.length; ++i) {\n        const rule = description.rules[i];\n\n        if (rule.name === 'has') {\n          rule.arg = rule.arg.describe();\n        }\n      }\n    }\n\n    return description;\n  }\n\n  items(...schemas) {\n    const obj = this.clone();\n    Hoek.flatten(schemas).forEach((type, index) => {\n      try {\n        type = Cast.schema(this._currentJoi, type);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = index + '.' + castErr.path;\n        } else {\n          castErr.path = index;\n        }\n\n        castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n        throw castErr;\n      }\n\n      obj._inner.items.push(type);\n\n      if (type._flags.presence === 'required') {\n        obj._inner.requireds.push(type);\n      } else if (type._flags.presence === 'forbidden') {\n        obj._inner.exclusions.push(type.optional());\n      } else {\n        obj._inner.inclusions.push(type);\n      }\n    });\n    return obj;\n  }\n\n  ordered(...schemas) {\n    const obj = this.clone();\n    Hoek.flatten(schemas).forEach((type, index) => {\n      try {\n        type = Cast.schema(this._currentJoi, type);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = index + '.' + castErr.path;\n        } else {\n          castErr.path = index;\n        }\n\n        castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n        throw castErr;\n      }\n\n      obj._inner.ordereds.push(type);\n    });\n    return obj;\n  }\n\n  min(limit) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    return this._testUnique('min', limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n          return this.createError('array.ref', {\n            ref: limit,\n            value: compareTo\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (value.length >= compareTo) {\n        return value;\n      }\n\n      return this.createError('array.min', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  max(limit) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    return this._testUnique('max', limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n          return this.createError('array.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (value.length <= compareTo) {\n        return value;\n      }\n\n      return this.createError('array.max', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  length(limit) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    return this._testUnique('length', limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n          return this.createError('array.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (value.length === compareTo) {\n        return value;\n      }\n\n      return this.createError('array.length', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  has(schema) {\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n      }\n\n      throw castErr;\n    }\n\n    return this._test('has', schema, function (value, state, options) {\n      const isValid = value.some((item, idx) => {\n        const localState = new State(idx, [...state.path, idx], state.key, state.reference);\n        return !schema._validate(item, localState, options).errors;\n      });\n\n      if (isValid) {\n        return value;\n      }\n\n      const patternLabel = schema._getLabel();\n\n      if (patternLabel) {\n        return this.createError('array.hasKnown', {\n          patternLabel\n        }, state, options);\n      }\n\n      return this.createError('array.hasUnknown', null, state, options);\n    });\n  }\n\n  unique(comparator, configs) {\n    Hoek.assert(comparator === undefined || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n    Hoek.assert(configs === undefined || typeof configs === 'object', 'configs must be an object');\n    const settings = {\n      ignoreUndefined: configs && configs.ignoreUndefined || false\n    };\n\n    if (typeof comparator === 'string') {\n      settings.path = comparator;\n    } else if (typeof comparator === 'function') {\n      settings.comparator = comparator;\n    }\n\n    return this._test('unique', settings, function (value, state, options) {\n      const found = {\n        string: Object.create(null),\n        number: Object.create(null),\n        undefined: Object.create(null),\n        boolean: Object.create(null),\n        object: new Map(),\n        function: new Map(),\n        custom: new Map()\n      };\n      const compare = settings.comparator || Hoek.deepEqual;\n      const ignoreUndefined = settings.ignoreUndefined;\n\n      for (let i = 0; i < value.length; ++i) {\n        const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n        const records = settings.comparator ? found.custom : found[typeof item]; // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n        // I still want to keep the test for future js versions with new types (eg. Symbol).\n\n        if (\n        /* $lab:coverage:off$ */\n        records\n        /* $lab:coverage:on$ */\n        ) {\n            if (records instanceof Map) {\n              const entries = records.entries();\n              let current;\n\n              while (!(current = entries.next()).done) {\n                if (compare(current.value[0], item)) {\n                  const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n                  const context = {\n                    pos: i,\n                    value: value[i],\n                    dupePos: current.value[1],\n                    dupeValue: value[current.value[1]]\n                  };\n\n                  if (settings.path) {\n                    context.path = settings.path;\n                  }\n\n                  return this.createError('array.unique', context, localState, options);\n                }\n              }\n\n              records.set(item, i);\n            } else {\n              if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n                const context = {\n                  pos: i,\n                  value: value[i],\n                  dupePos: records[item],\n                  dupeValue: value[records[item]]\n                };\n\n                if (settings.path) {\n                  context.path = settings.path;\n                }\n\n                return this.createError('array.unique', context, localState, options);\n              }\n\n              records[item] = i;\n            }\n          }\n      }\n\n      return value;\n    });\n  }\n\n  sparse(enabled) {\n    const value = enabled === undefined ? true : !!enabled;\n\n    if (this._flags.sparse === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.sparse = value;\n    return obj;\n  }\n\n  single(enabled) {\n    const value = enabled === undefined ? true : !!enabled;\n\n    if (this._flags.single === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.single = value;\n    return obj;\n  }\n\n  _fillMissedErrors(errors, requireds, state, options) {\n    const knownMisses = [];\n    let unknownMisses = 0;\n\n    for (let i = 0; i < requireds.length; ++i) {\n      const label = requireds[i]._getLabel();\n\n      if (label) {\n        knownMisses.push(label);\n      } else {\n        ++unknownMisses;\n      }\n    }\n\n    if (knownMisses.length) {\n      if (unknownMisses) {\n        errors.push(this.createError('array.includesRequiredBoth', {\n          knownMisses,\n          unknownMisses\n        }, {\n          key: state.key,\n          path: state.path\n        }, options));\n      } else {\n        errors.push(this.createError('array.includesRequiredKnowns', {\n          knownMisses\n        }, {\n          key: state.key,\n          path: state.path\n        }, options));\n      }\n    } else {\n      errors.push(this.createError('array.includesRequiredUnknowns', {\n        unknownMisses\n      }, {\n        key: state.key,\n        path: state.path\n      }, options));\n    }\n  }\n\n  _fillOrderedErrors(errors, ordereds, state, options) {\n    const requiredOrdereds = [];\n\n    for (let i = 0; i < ordereds.length; ++i) {\n      const presence = Hoek.reach(ordereds[i], '_flags.presence');\n\n      if (presence === 'required') {\n        requiredOrdereds.push(ordereds[i]);\n      }\n    }\n\n    if (requiredOrdereds.length) {\n      this._fillMissedErrors(errors, requiredOrdereds, state, options);\n    }\n  }\n\n};\n\ninternals.safeParse = function (value, result) {\n  try {\n    const converted = JSON.parse(value);\n\n    if (Array.isArray(converted)) {\n      result.value = converted;\n    }\n  } catch (e) {}\n};\n\nmodule.exports = new internals.Array();","map":null,"metadata":{},"sourceType":"script"}