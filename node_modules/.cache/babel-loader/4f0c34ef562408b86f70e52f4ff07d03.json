{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Any = require('../any');\n\nconst Cast = require('../../cast');\n\nconst Ref = require('../../ref'); // Declare internals\n\n\nconst internals = {};\ninternals.Alternatives = class extends Any {\n  constructor() {\n    super();\n    this._type = 'alternatives';\n\n    this._invalids.remove(null);\n\n    this._inner.matches = [];\n  }\n\n  _init(...args) {\n    return args.length ? this.try(...args) : this;\n  }\n\n  _base(value, state, options) {\n    const errors = [];\n    const il = this._inner.matches.length;\n    const baseType = this._baseType;\n\n    for (let i = 0; i < il; ++i) {\n      const item = this._inner.matches[i];\n\n      if (!item.schema) {\n        const schema = item.peek || item.is;\n        const input = item.is ? item.ref(state.reference || state.parent, options) : value;\n\n        const failed = schema._validate(input, null, options, state.parent).errors;\n\n        if (failed) {\n          if (item.otherwise) {\n            return item.otherwise._validate(value, state, options);\n          }\n        } else if (item.then) {\n          return item.then._validate(value, state, options);\n        }\n\n        if (i === il - 1 && baseType) {\n          return baseType._validate(value, state, options);\n        }\n\n        continue;\n      }\n\n      const result = item.schema._validate(value, state, options);\n\n      if (!result.errors) {\n        // Found a valid match\n        return result;\n      }\n\n      errors.push(...result.errors);\n    }\n\n    if (errors.length) {\n      return {\n        errors: this.createError('alternatives.child', {\n          reason: errors\n        }, state, options)\n      };\n    }\n\n    return {\n      errors: this.createError('alternatives.base', null, state, options)\n    };\n  }\n\n  try(...schemas) {\n    schemas = Hoek.flatten(schemas);\n    Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n    const obj = this.clone();\n\n    for (let i = 0; i < schemas.length; ++i) {\n      const cast = Cast.schema(this._currentJoi, schemas[i]);\n\n      if (cast._refs.length) {\n        obj._refs.push(...cast._refs);\n      }\n\n      obj._inner.matches.push({\n        schema: cast\n      });\n    }\n\n    return obj;\n  }\n\n  when(condition, options) {\n    let schemaCondition = false;\n    Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n    Hoek.assert(options, 'Missing options');\n    Hoek.assert(typeof options === 'object', 'Invalid options');\n\n    if (schemaCondition) {\n      Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n    } else {\n      Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n    }\n\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n    const obj = this.clone();\n    let is;\n\n    if (!schemaCondition) {\n      is = Cast.schema(this._currentJoi, options.is);\n\n      if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n        // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n        is = is.required();\n      }\n    }\n\n    const item = {\n      ref: schemaCondition ? null : Cast.ref(condition),\n      peek: schemaCondition ? condition : null,\n      is,\n      then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n      otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n    };\n\n    if (obj._baseType) {\n      item.then = item.then && obj._baseType.concat(item.then);\n      item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n    }\n\n    if (!schemaCondition) {\n      Ref.push(obj._refs, item.ref);\n\n      obj._refs.push(...item.is._refs);\n    }\n\n    if (item.then && item.then._refs.length) {\n      obj._refs.push(...item.then._refs);\n    }\n\n    if (item.otherwise && item.otherwise._refs.length) {\n      obj._refs.push(...item.otherwise._refs);\n    }\n\n    obj._inner.matches.push(item);\n\n    return obj;\n  }\n\n  label(name) {\n    const obj = super.label(name);\n    obj._inner.matches = obj._inner.matches.map(match => {\n      if (match.schema) {\n        return {\n          schema: match.schema.label(name)\n        };\n      }\n\n      match = Object.assign({}, match);\n\n      if (match.then) {\n        match.then = match.then.label(name);\n      }\n\n      if (match.otherwise) {\n        match.otherwise = match.otherwise.label(name);\n      }\n\n      return match;\n    });\n    return obj;\n  }\n\n  describe() {\n    const description = super.describe();\n    const alternatives = [];\n\n    for (let i = 0; i < this._inner.matches.length; ++i) {\n      const item = this._inner.matches[i];\n\n      if (item.schema) {\n        // try()\n        alternatives.push(item.schema.describe());\n      } else {\n        // when()\n        const when = item.is ? {\n          ref: item.ref.toString(),\n          is: item.is.describe()\n        } : {\n          peek: item.peek.describe()\n        };\n\n        if (item.then) {\n          when.then = item.then.describe();\n        }\n\n        if (item.otherwise) {\n          when.otherwise = item.otherwise.describe();\n        }\n\n        alternatives.push(when);\n      }\n    }\n\n    description.alternatives = alternatives;\n    return description;\n  }\n\n};\nmodule.exports = new internals.Alternatives();","map":null,"metadata":{},"sourceType":"script"}