{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Topo = require('topo');\n\nconst Any = require('../any');\n\nconst Errors = require('../../errors');\n\nconst Cast = require('../../cast');\n\nconst State = require('../state'); // Declare internals\n\n\nconst internals = {};\ninternals.Object = class extends Any {\n  constructor() {\n    super();\n    this._type = 'object';\n    this._inner.children = null;\n    this._inner.renames = [];\n    this._inner.dependencies = [];\n    this._inner.patterns = [];\n  }\n\n  _init(...args) {\n    return args.length ? this.keys(...args) : this;\n  }\n\n  _base(value, state, options) {\n    let target = value;\n    const errors = [];\n\n    const finish = () => {\n      return {\n        value: target,\n        errors: errors.length ? errors : null\n      };\n    };\n\n    if (typeof value === 'string' && options.convert) {\n      value = internals.safeParse(value);\n    }\n\n    const type = this._flags.func ? 'function' : 'object';\n\n    if (!value || typeof value !== type || Array.isArray(value)) {\n      errors.push(this.createError(type + '.base', {\n        value\n      }, state, options));\n      return finish();\n    } // Skip if there are no other rules to test\n\n\n    if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys\n    !this._inner.patterns.length) {\n      target = value;\n      return finish();\n    } // Ensure target is a local copy (parsed) or shallow copy\n\n\n    if (target === value) {\n      if (type === 'object') {\n        target = Object.create(Object.getPrototypeOf(value));\n      } else {\n        target = function (...args) {\n          return value.apply(this, args);\n        };\n\n        target.prototype = Hoek.clone(value.prototype);\n      }\n\n      const valueKeys = Object.keys(value);\n\n      for (let i = 0; i < valueKeys.length; ++i) {\n        target[valueKeys[i]] = value[valueKeys[i]];\n      }\n    } else {\n      target = value;\n    } // Rename keys\n\n\n    const renamed = {};\n\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      const rename = this._inner.renames[i];\n\n      if (rename.isRegExp) {\n        const targetKeys = Object.keys(target);\n        const matchedTargetKeys = [];\n\n        for (let j = 0; j < targetKeys.length; ++j) {\n          if (rename.from.test(targetKeys[j])) {\n            matchedTargetKeys.push(targetKeys[j]);\n          }\n        }\n\n        const allUndefined = matchedTargetKeys.every(key => target[key] === undefined);\n\n        if (rename.options.ignoreUndefined && allUndefined) {\n          continue;\n        }\n\n        if (!rename.options.multiple && renamed[rename.to]) {\n          errors.push(this.createError('object.rename.regex.multiple', {\n            from: matchedTargetKeys,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n          errors.push(this.createError('object.rename.regex.override', {\n            from: matchedTargetKeys,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (allUndefined) {\n          delete target[rename.to];\n        } else {\n          target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n        }\n\n        renamed[rename.to] = true;\n\n        if (!rename.options.alias) {\n          for (let j = 0; j < matchedTargetKeys.length; ++j) {\n            delete target[matchedTargetKeys[j]];\n          }\n        }\n      } else {\n        if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n          continue;\n        }\n\n        if (!rename.options.multiple && renamed[rename.to]) {\n          errors.push(this.createError('object.rename.multiple', {\n            from: rename.from,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n          errors.push(this.createError('object.rename.override', {\n            from: rename.from,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (target[rename.from] === undefined) {\n          delete target[rename.to];\n        } else {\n          target[rename.to] = target[rename.from];\n        }\n\n        renamed[rename.to] = true;\n\n        if (!rename.options.alias) {\n          delete target[rename.from];\n        }\n      }\n    } // Validate schema\n\n\n    if (!this._inner.children && // null allows any keys\n    !this._inner.patterns.length && !this._inner.dependencies.length) {\n      return finish();\n    }\n\n    const unprocessed = new Set(Object.keys(target));\n\n    if (this._inner.children) {\n      const stripProps = [];\n\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        const key = child.key;\n        const item = target[key];\n        unprocessed.delete(key);\n        const localState = new State(key, [...state.path, key], target, state.reference);\n\n        const result = child.schema._validate(item, localState, options);\n\n        if (result.errors) {\n          errors.push(this.createError('object.child', {\n            key,\n            child: child.schema._getLabel(key),\n            reason: result.errors\n          }, localState, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        } else {\n          if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n            stripProps.push(key);\n            target[key] = result.finalValue;\n          } else if (result.value !== undefined) {\n            target[key] = result.value;\n          }\n        }\n      }\n\n      for (let i = 0; i < stripProps.length; ++i) {\n        delete target[stripProps[i]];\n      }\n    } // Unknown keys\n\n\n    if (unprocessed.size && this._inner.patterns.length) {\n      for (const key of unprocessed) {\n        const localState = new State(key, [...state.path, key], target, state.reference);\n        const item = target[key];\n\n        for (let i = 0; i < this._inner.patterns.length; ++i) {\n          const pattern = this._inner.patterns[i];\n\n          if (pattern.regex ? pattern.regex.test(key) : !pattern.schema.validate(key).error) {\n            unprocessed.delete(key);\n\n            const result = pattern.rule._validate(item, localState, options);\n\n            if (result.errors) {\n              errors.push(this.createError('object.child', {\n                key,\n                child: pattern.rule._getLabel(key),\n                reason: result.errors\n              }, localState, options));\n\n              if (options.abortEarly) {\n                return finish();\n              }\n            }\n\n            target[key] = result.value;\n          }\n        }\n      }\n    }\n\n    if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n      if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {\n        const stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;\n\n        for (const key of unprocessed) {\n          if (stripUnknown) {\n            delete target[key];\n            unprocessed.delete(key);\n          } else if (typeof target[key] === 'function') {\n            unprocessed.delete(key);\n          }\n        }\n      }\n\n      if (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown) {\n        for (const unprocessedKey of unprocessed) {\n          errors.push(this.createError('object.allowUnknown', {\n            child: unprocessedKey,\n            value: target[unprocessedKey]\n          }, {\n            key: unprocessedKey,\n            path: [...state.path, unprocessedKey]\n          }, options, {}));\n        }\n      }\n    } // Validate dependencies\n\n\n    for (let i = 0; i < this._inner.dependencies.length; ++i) {\n      const dep = this._inner.dependencies[i];\n      const hasKey = dep.key !== null;\n      const splitKey = hasKey && dep.key.split('.');\n      const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\n      const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, {\n        functions: true\n      }), dep.peers, target, localState, options);\n\n      if (err instanceof Errors.Err) {\n        errors.push(err);\n\n        if (options.abortEarly) {\n          return finish();\n        }\n      }\n    }\n\n    return finish();\n  }\n\n  keys(schema) {\n    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n    Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n    const obj = this.clone();\n\n    if (!schema) {\n      obj._inner.children = null;\n      return obj;\n    }\n\n    const children = Object.keys(schema);\n\n    if (!children.length) {\n      obj._inner.children = [];\n      return obj;\n    }\n\n    const topo = new Topo();\n\n    if (obj._inner.children) {\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i]; // Only add the key if we are not going to replace it later\n\n        if (!children.includes(child.key)) {\n          topo.add(child, {\n            after: child._refs,\n            group: child.key\n          });\n        }\n      }\n    }\n\n    for (let i = 0; i < children.length; ++i) {\n      const key = children[i];\n      const child = schema[key];\n\n      try {\n        const cast = Cast.schema(this._currentJoi, child);\n        topo.add({\n          key,\n          schema: cast\n        }, {\n          after: cast._refs,\n          group: key\n        });\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = key + '.' + castErr.path;\n        } else {\n          castErr.path = key;\n        }\n\n        throw castErr;\n      }\n    }\n\n    obj._inner.children = topo.nodes;\n    return obj;\n  }\n\n  append(schema) {\n    // Skip any changes\n    if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n      return this;\n    }\n\n    return this.keys(schema);\n  }\n\n  unknown(allow) {\n    const value = allow !== false;\n\n    if (this._flags.allowUnknown === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.allowUnknown = value;\n    return obj;\n  }\n\n  length(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('length', limit, function (value, state, options) {\n      if (Object.keys(value).length === limit) {\n        return value;\n      }\n\n      return this.createError('object.length', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  min(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('min', limit, function (value, state, options) {\n      if (Object.keys(value).length >= limit) {\n        return value;\n      }\n\n      return this.createError('object.min', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  max(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('max', limit, function (value, state, options) {\n      if (Object.keys(value).length <= limit) {\n        return value;\n      }\n\n      return this.createError('object.max', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  pattern(pattern, schema) {\n    const isRegExp = pattern instanceof RegExp;\n    Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n    Hoek.assert(schema !== undefined, 'Invalid rule');\n\n    if (isRegExp) {\n      Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n    }\n\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n      }\n\n      throw castErr;\n    }\n\n    const obj = this.clone();\n\n    if (isRegExp) {\n      obj._inner.patterns.push({\n        regex: pattern,\n        rule: schema\n      });\n    } else {\n      obj._inner.patterns.push({\n        schema: pattern,\n        rule: schema\n      });\n    }\n\n    return obj;\n  }\n\n  schema() {\n    return this._test('schema', null, function (value, state, options) {\n      if (value instanceof Any) {\n        return value;\n      }\n\n      return this.createError('object.schema', null, state, options);\n    });\n  }\n\n  with(key, peers) {\n    Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n    return this._dependency('with', key, peers);\n  }\n\n  without(key, peers) {\n    Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n    return this._dependency('without', key, peers);\n  }\n\n  xor(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('xor', null, peers);\n  }\n\n  oxor(...peers) {\n    return this._dependency('oxor', null, peers);\n  }\n\n  or(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('or', null, peers);\n  }\n\n  and(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('and', null, peers);\n  }\n\n  nand(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('nand', null, peers);\n  }\n\n  requiredKeys(...children) {\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'required');\n  }\n\n  optionalKeys(...children) {\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'optional');\n  }\n\n  forbiddenKeys(...children) {\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'forbidden');\n  }\n\n  rename(from, to, options) {\n    Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n    }\n\n    const obj = this.clone();\n\n    obj._inner.renames.push({\n      from,\n      to,\n      options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n      isRegExp: from instanceof RegExp\n    });\n\n    return obj;\n  }\n\n  applyFunctionToChildren(children, fn, args = [], root) {\n    children = [].concat(children);\n    Hoek.assert(children.length > 0, 'expected at least one children');\n    const groupedChildren = internals.groupChildren(children);\n    let obj;\n\n    if ('' in groupedChildren) {\n      obj = this[fn](...args);\n      delete groupedChildren[''];\n    } else {\n      obj = this.clone();\n    }\n\n    if (obj._inner.children) {\n      root = root ? root + '.' : '';\n\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i];\n        const group = groupedChildren[child.key];\n\n        if (group) {\n          obj._inner.children[i] = {\n            key: child.key,\n            _refs: child._refs,\n            schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n          };\n          delete groupedChildren[child.key];\n        }\n      }\n    }\n\n    const remaining = Object.keys(groupedChildren);\n    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n    return obj;\n  }\n\n  _dependency(type, key, peers) {\n    peers = [].concat(peers);\n\n    for (let i = 0; i < peers.length; ++i) {\n      Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n    }\n\n    const obj = this.clone();\n\n    obj._inner.dependencies.push({\n      type,\n      key,\n      peers\n    });\n\n    return obj;\n  }\n\n  describe(shallow) {\n    const description = super.describe();\n\n    if (description.rules) {\n      for (let i = 0; i < description.rules.length; ++i) {\n        const rule = description.rules[i]; // Coverage off for future-proof descriptions, only object().assert() is use right now\n\n        if (\n        /* $lab:coverage:off$ */\n        rule.arg && typeof rule.arg === 'object' && rule.arg.schema && rule.arg.ref\n        /* $lab:coverage:on$ */\n        ) {\n            rule.arg = {\n              schema: rule.arg.schema.describe(),\n              ref: rule.arg.ref.toString()\n            };\n          }\n      }\n    }\n\n    if (this._inner.children && !shallow) {\n      description.children = {};\n\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        description.children[child.key] = child.schema.describe();\n      }\n    }\n\n    if (this._inner.dependencies.length) {\n      description.dependencies = Hoek.clone(this._inner.dependencies);\n    }\n\n    if (this._inner.patterns.length) {\n      description.patterns = [];\n\n      for (let i = 0; i < this._inner.patterns.length; ++i) {\n        const pattern = this._inner.patterns[i];\n\n        if (pattern.regex) {\n          description.patterns.push({\n            regex: pattern.regex.toString(),\n            rule: pattern.rule.describe()\n          });\n        } else {\n          description.patterns.push({\n            schema: pattern.schema.describe(),\n            rule: pattern.rule.describe()\n          });\n        }\n      }\n    }\n\n    if (this._inner.renames.length > 0) {\n      description.renames = Hoek.clone(this._inner.renames);\n    }\n\n    return description;\n  }\n\n  assert(ref, schema, message) {\n    ref = Cast.ref(ref);\n    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n    message = message || 'pass the assertion test';\n    Hoek.assert(typeof message === 'string', 'Message must be a string');\n\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n      }\n\n      throw castErr;\n    }\n\n    const key = ref.path[ref.path.length - 1];\n    const path = ref.path.join('.');\n    return this._test('assert', {\n      schema,\n      ref\n    }, function (value, state, options) {\n      const result = schema._validate(ref(value), null, options, value);\n\n      if (!result.errors) {\n        return value;\n      }\n\n      const localState = new State(key, ref.path, state.parent, state.reference);\n      return this.createError('object.assert', {\n        ref: path,\n        message\n      }, localState, options);\n    });\n  }\n\n  type(constructor, name = constructor.name) {\n    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n    const typeData = {\n      name,\n      ctor: constructor\n    };\n    return this._test('type', typeData, function (value, state, options) {\n      if (value instanceof constructor) {\n        return value;\n      }\n\n      return this.createError('object.type', {\n        type: typeData.name,\n        value\n      }, state, options);\n    });\n  }\n\n};\n\ninternals.safeParse = function (value) {\n  try {\n    return JSON.parse(value);\n  } catch (parseErr) {}\n\n  return value;\n};\n\ninternals.renameDefaults = {\n  alias: false,\n  // Keep old value in place\n  multiple: false,\n  // Allow renaming multiple keys into the same target\n  override: false // Overrides an existing key\n\n};\n\ninternals.groupChildren = function (children) {\n  children.sort();\n  const grouped = {};\n\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    Hoek.assert(typeof child === 'string', 'children must be strings');\n    const group = child.split('.')[0];\n    const childGroup = grouped[group] = grouped[group] || [];\n    childGroup.push(child.substring(group.length + 1));\n  }\n\n  return grouped;\n};\n\ninternals.keysToLabels = function (schema, keys) {\n  const children = schema._inner.children;\n\n  if (!children) {\n    return keys;\n  }\n\n  const findLabel = function (key) {\n    const matchingChild = schema._currentJoi.reach(schema, key);\n\n    return matchingChild ? matchingChild._getLabel(key) : key;\n  };\n\n  if (Array.isArray(keys)) {\n    return keys.map(findLabel);\n  }\n\n  return findLabel(keys);\n};\n\ninternals.with = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      return this.createError('object.with', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.without = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return this.createError('object.without', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.xor = function (key, value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (present.length === 1) {\n    return;\n  }\n\n  const context = {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n\n  if (present.length === 0) {\n    return this.createError('object.missing', context, state, options);\n  }\n\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.xor', context, state, options);\n};\n\ninternals.oxor = function (key, value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (!present.length || present.length === 1) {\n    return;\n  }\n\n  const context = {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.oxor', context, state, options);\n};\n\ninternals.or = function (key, value, peers, parent, state, options) {\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return;\n    }\n  }\n\n  return this.createError('object.missing', {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  }, state, options);\n};\n\ninternals.and = function (key, value, peers, parent, state, options) {\n  const missing = [];\n  const present = [];\n  const count = peers.length;\n\n  for (let i = 0; i < count; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      missing.push(peer);\n    } else {\n      present.push(peer);\n    }\n  }\n\n  const aon = missing.length === count || present.length === count;\n\n  if (!aon) {\n    return this.createError('object.and', {\n      present,\n      presentWithLabels: internals.keysToLabels(this, present),\n      missing,\n      missingWithLabels: internals.keysToLabels(this, missing)\n    }, state, options);\n  }\n};\n\ninternals.nand = function (key, value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  const main = peers[0];\n  const values = peers.slice(1);\n  const allPresent = present.length === peers.length;\n  return allPresent ? this.createError('object.nand', {\n    main,\n    mainWithLabel: internals.keysToLabels(this, main),\n    peers: values,\n    peersWithLabels: internals.keysToLabels(this, values)\n  }, state, options) : null;\n};\n\nmodule.exports = new internals.Object();","map":null,"metadata":{},"sourceType":"script"}